% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/recursiveBose.R
\name{recBoseCA}
\alias{recBoseCA}
\alias{recursiveBose}
\alias{N_k_recursiveBose}
\alias{N_d_recursiveBose}
\title{function to create a strength 2 CA based on recursive multiplication of Bose CAs}
\usage{
recBoseCA(t=2, k=NULL, v=4, type="PCA", ...)

recursiveBose(q, d=NULL, k=NULL, type="PCA", ...)

N_k_recursiveBose(q, d=2, type="PCA", ...)

N_d_recursiveBose(q, k, type="PCA", ...)
}
\arguments{
\item{t}{the requested strength; must be 2}

\item{k}{\code{NULL}, or the number of columns;\cr
if \code{NULL}, the maximum possible number for \code{d} is returned
(with \code{d} defaulting to 2, if not specified).}

\item{v}{the same as \code{q}}

\item{type}{\code{"CA"} or \code{"PCA"},
indicating whether \code{\link{productCA}} or
\code{\link{productPCA}} should be used for the product}

\item{...}{currently not used}

\item{q}{a prime or prime power number of levels}

\item{d}{\code{NULL}, or a small positive integer;\cr
\code{d=1} returns \code{SCA_Bose(q)} (q^2 x (q+1)),
\code{d} > 1 the product (\code{\link{productCA}} or \code{\link{productPCA}}, depending on \code{type})
of \code{d} \code{SCA_Bose(q)};\cr
For \code{d=NULL}, the minimum \code{d} for accommodating \code{k} is used.\cr
If \code{k} is also \code{NULL}, the default is \code{d=2}.}
}
\value{
\code{recBoseCA} returns a uniform CA strength 2 CA with \code{k} \code{v} level columns
(matrix of class \code{ca}); its rowsize can be determined a-priori with function \code{\link{N_recBoseCA}}.\cr
\code{recursiveBose} returns a uniform strength 2 CA with \code{q} level columns.\cr
For \code{type="PCA"} (default), the result has \code{d*q^2 - (d-1)*q} rows and
\code{q^d + d*q^(d-1)} columns, levels are coded from 0 to \code{q - 1}.\cr
For \code{type="CA"}, the result has \code{d*q^2 - (d-1)*2} rows (upper bound,
may be slightly smaller depending on constant rows) and
\code{(q+1)^d} columns, levels are coded from 0 to \code{q - 1}.\cr
\code{N_k_recursiveBose} returns a named vector with the number of rows and the number of columns k
for given \code{q} and \code{d}.\cr
\code{N_d_recursiveBose} returns a named vector with the run size \code{N}, the \code{d} for its creation for the requested number of columns \code{k}, and the maximum possible number of columns \code{kmax} for that construction.\cr
}
\description{
recBoseCA applies productCA or productPCA recursively to Bose CAs. The number of levels must be a prime or prime power.
}
\section{Details}{

The function \code{recBoseCA} uses function \code{recursiveBose}, which in turn uses
\code{\link{SCA_Bose}} for creating the \code{q^2 x (q+1)} ingredient matrix,
and either function \code{\link{productPCA}} or \code{\link{productCA}}
for obtaining the recursive product (depending on the choice for argument \code{type}).\cr
For a given $\code{v}$, the function can construct\cr
up to \code{v^d+d*v^(d-1)} columns in \code{d*v^2-(d-1)*v} runs (\code{type=="PCA"})\cr
or up to \code{(v+1)^d} columns in up to \code{d*v^2-(d-1)*2} runs (\code{type=="CA"}),\cr
where \code{d} is the number of Bose CAs that are combined.
}

\examples{
D <- recBoseCA(k=12)   ## v=4 is the default, and type="PCA"
dim(D)
coverage(D,2)
eCAN(2, 12, 4)
Ns(2, 12, 4) ## the optimum CA is available

D <- recBoseCA(k=25)   ## v=4 is the default, and type="PCA"
dim(D)
coverage(D,2)
eCAN(2, 25, 4)
Ns(2, 25, 4) ## the optimum CA is available
## type="CA" gets close to optimal here
## because k=25 makes it still work with d=2 SCA_Bose
D <- recBoseCA(k=25, type="CA")
dim(D)

dim(D <- recursiveBose(3))
eCAN(2,15,3)  ## optimal
dim(recursiveBose(3, d=3))
eCAN(2,54,3)  ## reasonably close to optimal
dim(recursiveBose(3, d=3, type="CA"))
eCAN(2,64,3)  ## reasonably close to optimal

## query functions
N_k_recursiveBose(4)      ## d=2
N_k_recursiveBose(4, 3)   ## d=3
N_d_recursiveBose(4, 12)  ## k=12

}
