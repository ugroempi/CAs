% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/recursiveBose.R
\name{recBoseCA}
\alias{recBoseCA}
\alias{recursiveBose}
\alias{N_k_recursiveBose}
\alias{N_d_recursiveBose}
\alias{Dd}
\alias{kd}
\title{function to create a strength 2 CA based on recursive multiplication of Bose CAs}
\usage{
recBoseCA(t=2, k=NULL, v=4, type="PCA", ...)

recursiveBose(q, d=NULL, k=NULL, type="PCA", ...)

N_k_recursiveBose(q, d=2, type="PCA", ...)

N_d_recursiveBose(q, k, type="PCA", ...)

Dd(d, q)

kd(d, q)
}
\arguments{
\item{t}{the requested strength; must be 2}

\item{k}{\code{NULL}, or the number of columns;\cr
if \code{NULL}, the maximum possible number for \code{d} is returned
(with \code{d} defaulting to 2, if not specified).}

\item{v}{the same as \code{q}}

\item{type}{\code{"CA"} or \code{"PCA"},
indicating whether \code{\link{productCA}} or
\code{\link{productPCA}} should be used for the product}

\item{...}{currently not used}

\item{q}{a prime or prime power number of levels}

\item{d}{\code{NULL}, or a small positive integer;\cr
\code{d=1} returns \code{SCA_Bose(q)} (q^2 x (q+1)),
\code{d} > 1 the product (\code{\link{productCA}} or \code{\link{productPCA}}, depending on \code{type})
of \code{d} \code{SCA_Bose(q)};\cr
For \code{d=NULL}, the minimum \code{d} for accommodating \code{k} is used.\cr
If \code{k} is also \code{NULL}, the default is \code{d=2}.}
}
\value{
\code{recBoseCA} returns a uniform CA strength 2 CA with \code{k} \code{v} level columns
(matrix of class \code{ca}); its rowsize can be determined a-priori with function \code{\link{N_recBoseCA}}.\cr
\code{recursiveBose} returns a uniform strength 2 CA with \code{q} level columns.\cr
For \code{type="PCA"} (default), the result has \code{d*q^2 - (d-1)*q} rows and
\code{q^d + d*q^(d-1)} columns, levels are coded from 0 to \code{q - 1}.\cr
For \code{type="CA"}, the result has \code{d*q^2 - (d-1)*2} rows (upper bound,
may be slightly smaller depending on constant rows) and
\code{(q+1)^d} columns, levels are coded from 0 to \code{q - 1}.\cr
\code{N_k_recursiveBose} returns a named vector with the number of rows and the number of columns k
for given \code{q} and \code{d}.\cr
\code{N_d_recursiveBose} returns a named vector with the run size \code{N}, the \code{d} for its creation for the requested number of columns \code{k}, and the maximum possible number of columns \code{kmax} for that construction.\cr
}
\description{
recBoseCA applies productCA or productPCA recursively to Bose CAs. The number of levels must be a prime or prime power.
}
\section{Details}{

The function \code{recBoseCA} uses function \code{recursiveBose}, which in turn uses
\code{\link{SCA_Bose}} for creating the \code{q^2 x (q+1)} ingredient matrix,
and either function \code{\link{productPCA}} or \code{\link{productCA}}
for obtaining the recursive product (depending on the choice for argument \code{type}).

\code{type=PCA}: For a given \code{v}, the function can construct
up to \code{kd(d,v)} columns in \code{d*v^2-(d-1)*v} runs,
where \code{d} is the number of Bose CAs that are combined,
and \code{k(d,v)} has been determined by experimentation; for \code{d=2,3},
\code{k(d,v)} coincides with the value stated in Colbourn et al. (2006) Lemma 3.5,
which uses a recursively defined \code{Dd(0,v)=0}, \code{Dd(1,v)=1}, \code{Dd(d+1,v)=v*(Dd(d,v) + Dd(d-1,v))}
to yield \code{k=(v+1)*Dd(d,v) + v*Dd(d-1,v)}. Different from the construction
underlying Lemma 3.5 of Colbourn et al. (2006), this function improves the
size of the left-hand side partition in each interim step; this is achieved by
applying function \code{\link{CA_to_PCA}} after moving the first block of \code{v} rows
Experimentation showed that this choice yielded the overall optimum result among
blocks of \code{v} rows in all cases that were investigated.

For \code{type=="CA"}: For a given \code{v}, the function can construct up to \code{(v+1)^d}
columns in up to \code{d*v^2-(d-1)*2} runs (\code{type=="CA"}),
where \code{d} is the number of Bose CAs that are combined.
}

\examples{
D <- recBoseCA(k=12)   ## v=4 is the default, and type="PCA"
dim(D)
coverage(D,2)
eCAN(2, 12, 4)
Ns(2, 12, 4) ## the optimum CA is available

D <- recBoseCA(k=25)   ## v=4 is the default, and type="PCA"
dim(D)
coverage(D,2)
eCAN(2, 25, 4)
Ns(2, 25, 4) ## the optimum CA is available
## type="CA" gets close to optimal here
## because k=25 makes it still work with d=2 SCA_Bose
D <- recBoseCA(k=25, type="CA")
dim(D)

dim(D <- recursiveBose(3))
eCAN(2,15,3)  ## optimal
dim(recursiveBose(3, d=3))
eCAN(2,57,3)  ## reasonably close to optimal
dim(recursiveBose(3, d=3, type="CA"))
eCAN(2,64,3)  ## reasonably close to optimal

## query functions
N_k_recursiveBose(4)      ## d=2
N_k_recursiveBose(4, 3)   ## d=3
kd(3,4)   ## work horse function for k for default type PCA
N_k_recursiveBose(4, 3, type="CA")
N_d_recursiveBose(4, 12)  ## k=12

}
\references{
Colbourn et al. (2006)
}
