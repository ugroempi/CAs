% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/productPCA.R
\name{productPCA}
\alias{productPCA}
\alias{SCA_Bose}
\alias{CA_to_PCA}
\alias{is.PCA}
\title{Functions for partitioned CAs and their products}
\usage{
productPCA(D1, D2=NULL, k1=NULL, l1=NULL, ...)

SCA_Bose(q, ...)

CA_to_PCA(D, tryhard=FALSE, ...)

is.PCA(D, start0=NULL, ...)
}
\arguments{
\item{D1}{an N x k CA of strength 2 with v levels, split into k1 + k2 columns for \code{productPCA}}

\item{D2}{an N x l CA of strength 2 with v levels, split into l1 + l2 columns for \code{productPCA}}

\item{k1}{width of P block in \code{D1} (see Details section)}

\item{l1}{width of P block in \code{D2} (see Details section)}

\item{...}{currently not used}

\item{D}{an N x k CA of strength 2 with v levels}

\item{q}{a prime power for the Bose construction}

\item{tryhard}{logical: if \code{TRUE}, \code{CA_to_PCA} tries to achieve \code{v} constant rows for \code{k-1} or \code{k-2} columns; this may take a while in case of many columns.}

\item{start0}{\code{NULL}, or logical: do the values start with 0 (otherwise with 1)?}
}
\value{
Function {\code{productPCA}} returns a new PCA in \code{k1*l1 + k1*l2 + k2*l1} columns and \code{N + M - v} rows
(matrix of class \code{ca}).\cr
The returned matrix has its levels coded like the ingoing matrices, i.e., integers starting with 0 or 1.

Function \code{CA_to_PCA} returns an equivalent CA of S3 class \code{ca} that has PCA (or SCA) structure (see Section "Partitioned Covering Array (PCA)").

Function\code{SCA_Bose} creates a Bose array from \code{\link[lhs]{createBose}} and rearranges its columns
into SCA structure (see Section "Partitioned Covering Array (PCA)").

The results of functions \code{CA_to_PCA}, \code{SCA_Bose} and {\code{prodPCA}} have an attribute \code{PCAstatus},
which is a list with elements \code{type} (PCA or SCA), \code{k1} and \code{k2}.

Function \code{is.PCA} returns a logical with the analogous attribute; it can be (mis)used for checking
consistency between the codings of designs by specifying \code{start0}.
}
\description{
Functions for partitioned CAs (PCAs) of coverage strength 2, and for a product of two PCAs.
The number of rows of a product of a PCA(N, 2, k, v) and a PCA(M, 2, l, v) is N + M - v,
the number of columns depends on the splits k = k1+k2 and l = l1+l2.
}
\section{Details}{

Function \code{productPCA} exploits a partitioned structure of the two CAs it combines
(see Section "Partitioned Covering Array (PCA)"). The construction can be viewed as a kind of product,
but is sometimes also called "cut-and-paste". It was proposed in Colbourn et al. (2006)
and was slightly generalized later, see, e.g., in Colbourn and Torres-Jimenez (2013).

Function \code{productPCA} also serves as work horse function for combining two CAs in many instances of
the \code{\link{CAEX}} construction.

\code{CA_to_PCA} rearranges \code{D} into a PCA structure (see Section "Partitioned Covering Array (PCA)")
by rearranging columns, swapping symbols, and in case of \code{tryhard=TRUE} also rearranging rows.\cr
In case of \code{tryhard=TRUE}, it is tried to achieve PCA status \code{k2=1} or \code{k2=2}; in that case,
if it is possible to achieve \code{v} constant rows (i.e., \code{k2=0}), the function finds these.\cr
Without \code{tryhard=TRUE}, the resulting PCA will have \code{k1} as the number of columns with \code{v} different
levels in the first \code{v} rows.\cr
\code{tryhard=TRUE} may be useful for small designs, but may substantially increase run times for \code{D} with many rows or many columns.

Function \code{SCA_Bose} obtains the strength 2 Bose constructed CA (q+1 columns in q levels, q^2 runs, q a prime power)
and rearranges it into SCA shape.

Function \code{CA_to_PCA} brings its argument into the best possible PCA shape by swapping columns only.
If the argument \code{tryhard} is invoked, the function tries to achieve \code{k1=k-1} or \code{k1=k-2} by trying \code{\link{maxconstant}} on
subsets of columns. Function \code{is.PCA} checks the PCA status of its argument without modifying it in any way.
}

\section{Partitioned Covering Array (PCA)}{

For an \code{N x k} CA(N, t, k, v) to be a PCA, the number of columns is split into \code{k = k1 + k2}, with \code{k1>0} (otherwise no PCA),
the number of rows is split into \code{N = v + (N - v)}; such a PCA is denoted as PCA(N, t, (k1,k2), v).\cr
The PCA structure, in this package, is arranged with top and bottom parts swapped versus
partitioning of Colbourn et al. (2006). Parts are arranged here such that\cr
the \code{v x k1} matrix P (with each column consisting of the identity permutation of all levels)
makes up the top left block,\cr
the top right \code{v x k2} block (which may be empty) is constant with all elements equal to the smallest level (for an SCA, which is a special case of a PCA)
or has arbitrary levels (for a PCA),\cr
and the remaining two blocks (bottom left and bottom right) may arbitrary elements.
}

\examples{
#################################################
### productPCA
#################################################
A <- SCA_Bose(4)  ## Bose array, arranged as SCA
EPCA <- productPCA(A, A)
coverage(EPCA, 2)
dim(EPCA)  ## 24 columns only, 28 runs only
eCAN(2, 24, 4) ## optimal, this construction!
eCAK(2, 28, 4) ## optimal, this construction

########################################
## utilities CA_to_PCA and is.PCA
########################################
SCA61.2..9.1..7 <- CA_to_PCA(CS_MS(10, 7), tryhard=TRUE)
attributes(SCA61.2..9.1..7)

is.PCA(DoE.base::L36.2.8.6.3[,-(1:8)])
CA_to_PCA(DoE.base::L36.2.8.6.3[,-(1:8)])

## utility SCA_Bose
SCA_Bose(3)

## apply PCA construction
E <- productPCA(SCA_Bose(3))
dim(E)
coverage(E,2)
eCAN(2,15,3)  ## optimal for 15 columns
eCAK(2,15,3)  ## but does not cover 20 columns

## for non-prime power case
## use optimum CA(46,2,9,6)
MS6 <- CS_MS(k=9, v=6)
MS6 <- CA_to_PCA(MS6)
MS6 <- CA_to_PCA(MS6, tryhard=TRUE)
head(MS6)  ## it is an SCA with k1=8 and k2=9
dim(CA.86.6.80 <- productPCA(MS6, MS6))
## four too many runs
eCAN(2,80,6)

## another case
head(DoE.base::L36.2.8.6.3[,-(1:8)]) ## it is an SCA with k1=3 and k2=0,
                                     ## as all columns have six distinct
                                     ## values in first six rows
dim(productPCA(MS6, CA_to_PCA(DoE.base::L36.2.8.6.3[,-(1:8)] - 1)))
eCAN(2,27,6)  ## 8 too many runs

## the function also works for designs with flexible values (which are denoted by NA)
## productPCA
D <- productPCA(CAEX(N=16), CAEX(N=16))
dim(D)
eCAN(2,405,3) ## slightly worse than the best CA, which is obtained as CAEX(N=27)
is.PCA(D) ## is already good and cannot be further improved by the simple method used in CA_to_PCA
\dontrun{coverage(D, 2)} ## slightly longer run time

}
\references{
Colbourn et al. (2006), Colbourn and Torres-Jimenez (2013), Torres-Jimenez et al. (2019)
}
