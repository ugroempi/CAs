% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/greedySCA_TJ.R
\name{greedySCA_TJ}
\alias{greedySCA_TJ}
\alias{iter_greedySCA_TJ}
\title{Greedy random creation of an SCA}
\usage{
greedySCA_TJ(k, t, postopt=TRUE, seed=NULL, ...)

iter_greedySCA_TJ(niter, k, t, seed_init=NULL, verbose=TRUE, ...)
}
\arguments{
\item{k}{positive integer (at least t); the number of columns}

\item{t}{the strength for which the coverage of all permutations of length t must be guaranteed for all \code{combn(k,t)} t-element subsets of 1,...,k}

\item{postopt}{logical; default depends on function; if TRUE, the function \code{\link{reduce_rows_iterative_complete}} tries to make rows redundant and remove them. If this takes too long, \code{postopt} should be FALSE.}

\item{seed}{an optional positive integer seed for random sampling; specifying a seed makes the array generation reproducible}

\item{...}{currently not used}

\item{niter}{the number of independent attempts to make}

\item{seed_init}{an optional positive integer seed for the first iteration; specifying a seed makes the array generation reproducible}

\item{verbose}{logical (default TRUE), controlling how much printed output is created}
}
\value{
a strength t SCA with k columns; all rows contain the integers 1 to k.
}
\description{
for k columns and strength t according to an algorithm by Torres-Jimenez et al. (2022)
}
\section{Details}{

The function \code{greedySCA_TJ} implements the construction of Torres-Jimenez et al. (2022). It
uses an approach based on directed acyclic graphs and relies on the R package igraph for that
purpose.\cr
For \code{postopt=TRUE}, it then \emph{identifies the redundant elements and removes all rows that
contain redundant elements only (would be easiest, but at present not done)} applies iterative run size reduction
using function \code{reduce_rows_iterative_complete}.

The function \code{iter_greedySCA_TJ} iteratively repeats the process and keeps the best
outcome.

Torres-Jimenez et al. (2022) describe a 3-stage approach, the third stage of which is
simulated annealing. Simulated annealing is invoked if the iterative reduction process is unable
to find a row that can be removed without deteriorating coverage. While this stage is needed for
achieving the very good performance that the paper reports on, it is often excessively slow at least
in the implementation of this package.
}

\section{Use of AI}{

Claude 4 was involved in the development of these functions (mainly for debugging).
}

\examples{
## without post-optimization
nrow(greedySCA_TJ(5, 3, seed=2323, postopt=FALSE))
## relatively unlucky
nrow(greedySCA_TJ(5, 3, seed=222, postopt=FALSE))
## relatively lucky
nrow(A <- greedySCA_TJ(5, 3, seed=8881, postopt=FALSE))
coverageSCA(A, 3)
coverageSCA(A, 4)

## with post-optimization
## differences become smaller (still relevant esp. for larger cases)
nrow(greedySCA_TJ(5, 3, seed=2323))
## relatively unlucky
nrow(greedySCA_TJ(5, 3, seed=222))
## very lucky
nrow(A <- greedySCA_TJ(5, 3, seed=8881))
coverageSCA(A, 3)
coverageSCA(A, 4) ## worse coverage of 4-sequences than for larger SCA

## iteration
nrow(iter_greedySCA_TJ(10, 5, 3, seed_init=222)) ## start unlucky
  ## larger niter brings the run size down to 8
}
\references{
Torres-Jimenez et al. (2022)
}
\seealso{
\code{\link[=greedySCA_naive]{greedySCA_naive()}} for a naive greedy random assembly of an SCA and \code{\link[=greedySCA_Kuhn]{greedySCA_Kuhn()}} for the greedy method by Kuhn et al. (2012)
}
\author{
Ulrike Groemping
}
