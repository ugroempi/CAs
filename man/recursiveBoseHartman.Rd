% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/recursiveBoseHartman.R
\name{recursiveBoseHartman}
\alias{recursiveBoseHartman}
\alias{N_k_recursiveBoseHartman_A}
\alias{N_k_recursiveBoseHartman_d}
\alias{N_d_recursiveBoseHartman}
\title{function to increase numbers of columns for strength 2 CA in q levels (q prime power) from k to kq+1}
\usage{
recursiveBoseHartman(q, A=NULL, d=NULL, ...)

N_k_recursiveBoseHartman_A(q, A, ...)

N_k_recursiveBoseHartman_d(q, d=2, ...)

N_d_recursiveBoseHartman(q, k, ...)
}
\arguments{
\item{q}{a prime or prime power number of levels}

\item{A}{\code{NULL}, or a uniform CA of strength 2 in N rows and k columns with integer-valued levels (0 to q-1 or 1 to q). \code{A} takes precedence over \code{d}.}

\item{d}{\code{NULL}, or a small positive integer; 1 returns the Bose OA (q^2 x (q+1)), d>1 the processed Bose OA in d*(q^2) - (d-1)*q runs and q^d+q^(d-1)+...+q+1 columns.\cr
For \code{recursiveBose}, if \code{A} is specified, \code{d} is ignored.\cr
For \code{k_recursiveBose}, the default is \code{d=2} for \code{N=2q^2 - q}; it can be increased, if k is too small; each increase by 1 will increase N by \code{q^2 - q}}

\item{...}{currently not used}

\item{k}{the number of columns requested}
}
\value{
\code{recursiveBoseHartman} returns a uniform strength 2 CA with \code{q} level columns.\cr
If neither \code{A} nor \code{d} are specified,
the result has \code{2q^2 - q} rows and \code{q^2 + q + 1} columns,
levels are coded from 0 to \code{q - 1}.\cr
If \code{A} is specified, the result has \code{N + q^2 - q} rows and \code{q*k + q + 1} columns,
in the same coding as \code{A}.\cr
If \code{d} is specified and \code{A=NULL},
the result has \code{d*q^2 - (d-1)*q} rows and \code{sum_i=0^d q^i} columns,
coded from 0 to \code{q}-1.\cr
\code{N_k_recursiveBoseHartman_A} returns a named vector with the run size \code{N} and the number of columns \code{k} for given \code{q} and \code{A}.\cr
\code{k_recursiveBoseHartman} returns the number of columns k for given \code{q} and \code{d}.\cr
\code{N_d_recursiveBoseHartman} returns a named vector with the run size \code{N}, the \code{d} for its creation for the requested number of columns \code{k}, and the maximum possible number of columns \code{kmax} for that construction.\cr
}
\description{
applies construction principle of Hartman (2005) Thm 7.1 and Corollary 7.2
}
\section{Details}{

The function uses a method presented by Hartman (2005) (Theorem 7.1 and Corollary 7.2).
For \code{A=NULL}, the function uses \code{lhs::createBose(q, q+1, bRandom=FALSE)} for creating A
The user can specify any uniform strength 2 CA for \code{A}; the extension to more columns and runs will always use the Bose OA without the first q rows, and thus always add \code{q^2-q} rows.
}

\examples{
dim(D <- recursiveBoseHartman(3))
eCAN(2,13,3)  ## optimal
dim(recursiveBoseHartman(3, d=2))
dim(D2 <- recursiveBoseHartman(3, D))
eCAN(2,40,3)  ## reasonably close to optimal
dim(recursiveBoseHartman(3, d=3))
dim(D3 <- recursiveBoseHartman(3, D2))
eCAN(2,121,3)  ## still reasonably close to optimal
dim(recursiveBoseHartman(3,d=4))

## constructions with A=NULL are optimal
for (q in c(4,5,7,9,11,13,16)){
  D <- recursiveBoseHartman(q)
  cat(paste0("q=", q, "\n"))
  cat(paste0("constructed: ",
     paste(paste0(c("N=","ncolumns="),dim(D)), collapse=", "), "\n"))
  Nopt <- eCAN(2,ncol(D),q)[1]   ## optimal
  cat(paste0("optimal for ", ncol(D), " columns: ", Nopt, " runs\n"))
}

#' ## constructions of first recursion are optimal or reasonably close
for (q in c(4,5,7,9,11,13,16)){
  D <- recursiveBoseHartman(q)
  D <- recursiveBoseHartman(q, D)
  cat(paste0("q=", q, "\n"))
  cat(paste0("constructed: ",
     paste(paste0(c("N=","ncolumns="),dim(D)), collapse=", "), "\n"))
  Nopt <- eCAN(2,ncol(D),q)[1]   ## optimal
  cat(paste0("optimal for ", ncol(D), " columns: ", Nopt, " runs\n"))
}

## a general A, an OA in 11 5-level columns at strength 2
## coded starting with 1
A <- matrix(as.numeric(as.matrix(
     DoE.base::oa.design(nlevels=rep(5,11), randomize=FALSE))),
   nrow=50)
head(A)
## number of columns increased from 11 to 56
## number of rows increased by 5^2 - 5 = 20
## still strength 2
dim(D <- recursiveBoseHartman(5, A))
coverage(D, 2, start0=FALSE)
## 25\% more runs than the best CA
eCAN(2,56,5)

## recursive with d=1
recursiveBose(3,d=1)

## query functions
N_k_recursiveBoseHartman_A(4, lhs::createBose(4, 5))
N_k_recursiveBoseHartman_d(4,4)
N_d_recursiveBoseHartman(4, 12)

}
