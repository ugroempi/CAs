% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/crossSum.R
\name{crossSum}
\alias{crossSum}
\alias{directSum}
\title{Cross-sum two codes with k columns in v levels}
\usage{
crossSum(A, B, ...)

directSum(A, B, ...)
}
\arguments{
\item{A}{an N x k code with (up to) \code{v} levels; for \code{v=Inf},
elements of \code{A} and \code{B} must not be negative (otherwise, \code{directSum} may return {Inf} elements).}

\item{B}{an M x l code with (up to) \code{v} levels; for function \code{crossSum}, \code{l=k} is needed.}

\item{...}{currently not used}
}
\value{
\code{directSum} returns an \code{N*M x (k+l)} matrix.\cr
\code{crossSum} returns an \code{N*M x k} matrix, which has its levels
coded like the ingoing matrices, i.e., integer starting with 0 or 1.
}
\description{
Function to construct cross-sum two codes in k columns at v levels, according to CKRS (2010)
}
\section{Details}{

The convenience function \code{directSum} yields
\code{cbind(kronecker(A, matrix(1,M,1)), kronecker(matrix(1,N,1), B)}, i.e.,
it concatenates all pairs of rows of matrices \code{A} and \code{B}.

Function \code{crossSum} yields an \code{N*M x k} matrix by adding all pairs of
rows from \code{A} and \code{B} (each row of \code{A} to all columns of \code{B}).
According to CKRS (2010), it is most promising to choose \code{A} as a repetition code (RC) (e.g.,
with rows 0000 1111 2222, for with k=4 and v=3), an RC extended by a
few constant columns (ERC, e.g., 000000 111100 222200),
a direct sum of repetition codes (DRC, e.g., rows
0000000000000000 1111111111111111 2222222222222222 1111111111111111
2222222222222222 0000000000000000 2222222222222222 0000000000000000
1111111111111111 for the above RC with itself),
or a DRC extended by a few constant columns EDRC.
}

\examples{
################################################
## crossSum
################################################
## two codes with fourteen columns each
## A a repetition code
A <- matrix(0:2, 3, 14)
dim(A)
## B from Fig. 1 of CKRS
B <- rbind(
c(0,0,0,0,0,0,0,0,0,0,0,0,0,0), c(0,2,2,2,1,1,2,0,2,0,0,2,1,1),
c(2,0,2,0,1,2,0,1,0,1,1,1,0,2), c(1,0,1,2,2,2,1,1,0,0,0,2,0,0),
c(2,0,0,2,0,0,1,1,2,1,2,1,2,1), c(0,0,1,1,0,2,1,2,2,2,1,0,1,2),
c(1,2,0,0,0,2,1,2,1,0,0,1,2,2), c(0,0,1,2,1,0,0,2,1,0,1,2,2,1),
c(2,2,1,0,2,0,1,0,0,2,1,1,2,1), c(1,2,0,2,1,0,2,1,1,2,1,0,0,2),
c(0,2,2,0,1,0,1,1,2,0,0,2,1,2), c(0,0,1,2,2,0,2,0,1,1,0,1,1,2),
c(2,1,1,1,2,0,0,1,2,0,0,0,2,2), c(0,1,0,0,2,2,2,1,2,0,1,1,0,1),
c(0,2,1,0,1,2,2,1,1,1,2,0,2,0), c(0,2,0,2,2,2,0,0,2,1,1,2,2,2),
c(0,2,1,2,0,0,1,0,2,2,2,2,0,0)
)

dim(B)
## cross-sum array with 3*17=51 runs
E <- crossSum(A, B)
dim(E)
coverage(E, 3)
eCAN(3, 14, 3)      ## the CA is not optimal
eCAK(3, 51, 3)      ## the optimal strength 3 3-level CA
                    ## in 51 runs accommodates two more columns
}
\references{
Colbourn, Keri, Rivas Soriani and Schlage-Puchta (2010, CKRS)
}
