% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/greedySCA_naive.R
\name{greedySCA_naive}
\alias{greedySCA_naive}
\alias{iter_greedySCA_naive}
\title{Greedy random creation of an SCA}
\usage{
greedySCA_naive(k, t, seed=NULL, postopt=TRUE, ...)

iter_greedySCA_naive(niter, k, t, seed_init=NULL, verbose=TRUE, ...)
}
\arguments{
\item{k}{positive integer (at least t); the number of columns}

\item{t}{the strength for which the coverage of all permutations of length t must be guaranteed for all \code{combn(k,t)} t-element subsets of 1,...,k}

\item{seed}{an optional positive integer seed for random sampling; specifying a seed makes the array generation reproducible}

\item{postopt}{logical; default TRUE, i.e., rows with all elements redundant are identified and removed. If this takes too long, change to FALSE}

\item{...}{currently not used}

\item{niter}{number of independent attempts}

\item{seed_init}{initial seed for iterative application}

\item{verbose}{logical (default TRUE), controlling how much printed output is created}
}
\value{
a strength t SCA with k columns; all rows contain the integers 1 to k.
}
\description{
for k columns and strength t
}
\section{Details}{

Function \code{greedySCA_naive} starts from t! random permutations of the the
integers 1,...,k and adds a further random permutation,
until all orders of all t-tuples are covered. For \code{postopt=TRUE},
it then identifies the redundant elements and removes all rows that
contain redundant elements only.

Function \code{iter_greedySCA_naive} makes \code{niter} independent attempts and
improves the best of those by removing rows that contain redundant elements only.
}

\section{Use of AI}{

Claude 4 was involved in the development of these functions.
}

\examples{
## without post-optimization
nrow(greedySCA_naive(5, 3, seed=2323, postopt=FALSE))
## relatively unlucky
nrow(greedySCA_naive(5, 3, seed=2415, postopt=FALSE))
## relatively lucky
nrow(A <- greedySCA_naive(5, 3, seed=9456, postopt=FALSE))
coverageSCA(A, 3)
coverageSCA(A, 4)

## with post-optimization
## differences become less dramatic (but still relevant)
nrow(greedySCA_naive(5, 3, seed=2323))
## relatively unlucky
nrow(greedySCA_naive(5, 3, seed=2415))
## relatively lucky
nrow(A <- greedySCA_naive(5, 3, seed=9456))
coverageSCA(A, 3)
coverageSCA(A, 4) ## worse coverage of 4-sequences than for larger SCA

## iterative with unlucky start
Aiter <- iter_greedySCA_naive(10, 5, 3, seed_init=2415)
nrow(Aiter)
## niter=20 better than niter=10
Aiter <- iter_greedySCA_naive(20, 5, 3, seed_init=2415)
nrow(Aiter)

## further improvement is possible by more substantial attempt
nrow(reduce_rows_iterative_complete(Aiter, 3))
}
\seealso{
\code{\link[=greedySCA_Kuhn]{greedySCA_Kuhn()}} for the greedy method by Kuhn et al. (2012) and \code{\link[=greedySCA_TJ]{greedySCA_TJ()}} for the greedy stage method of Torres-Jimenez et al. (2022)
}
\author{
Ulrike Groemping
}
