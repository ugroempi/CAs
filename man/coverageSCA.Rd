% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/coverageSCA.R
\name{coverageSCA}
\alias{coverageSCA}
\title{Checking coverage for SCAs}
\usage{
coverageSCA(A, t, stop_at_first_failure=FALSE, verbose=FALSE, ...)
}
\arguments{
\item{A}{a sequence covering array (SCA) with k columns and elements 1,...,k in each row}

\item{t}{the strength for which the coverage of all permutations of length t must be guaranteed for all \code{combn(k,t)} t-element subsets of 1,...,k}

\item{stop_at_first_failure}{logical; if \code{TRUE}, the function returns FALSE instead of a number}

\item{verbose}{logical; if \code{TRUE}, the returned object has an attribute \code{uncovered} with the uncovered sequences}

\item{...}{currently not used}
}
\value{
a number between 0 and 1 with attributes; the number is the proportion of covered orders (may be made more detailed in the future).\cr
The attribute \code{count_effective} holds the counts for each row of A of the number of sequences covered here but not earlier, as proposed by Murray and Colbourn (2015).\cr
If the proportion is smaller than one, and if \code{verbose=TRUE}, the uncovered sequences are available in the attribute \code{uncovered} of the returned value.
}
\description{
for a given SCA A and a strength t
}
\section{Usefulness}{

It is particularly relevant to check whether the coverage is perfect, i.e., the outcome is 1. If this is the only interest, one can stop at the first failure.
}

\examples{
### create a trivial SCA of strength 2
A <- rbind(1:5, 5:1)
coverageSCA(A, 2)
coverageSCA(A, 3) ## covers a third of the 3-factor orders

## a naive greedy SCA of strength 3
A <- greedySCA_naive(5, 3, seed=2323)
dim(A)
coverageSCA(A,3)

A <- reduce_rows_iterative_complete(A, 3)

## also works from worse starting matrix
A <- greedySCA_naive(5, 3, seed=589)
dim(A)
A <- reduce_rows_iterative_complete(A, 3)
dim(A)   ## substantially reduced in very short time

}
