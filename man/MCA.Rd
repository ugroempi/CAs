% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MCA.R
\name{CA_to_MCA}
\alias{CA_to_MCA}
\alias{MCA2}
\alias{N_upper_MCA}
\alias{projBoseMCA}
\title{Making mixed-level CAs}
\usage{
MCA2(nlevels, D=NULL, outerRetry=10, innerRetry=1, seed=NULL, ...)

CA_to_MCA(D, cs, tolevs, t=attr(D, "t"), outerRetry=10, innerRetry=1, seed=NULL, ...)

N_upper_MCA(nlevels, t=2, internet = TRUE, ...)

projBoseMCA(nlevels, t=2, ...)
}
\arguments{
\item{D}{a strength \code{t} CA (it may have mixed levels)}

\item{cs}{integer vector of column numbers}

\item{tolevs}{integer vector of target numbers of levels for the columns indicated
by \code{cs}; must not be larger than the number of levels of the related
columns in \code{cs}, and must not be smaller than 2}

\item{t}{integer, the strength of \code{D} (smaller strength would be permitted,
but would not make sense) or the requested strength}

\item{outerRetry}{passed to \code{\link{postopNCK}}; if \code{0},
run size reduction will not be attempted.}

\item{innerRetry}{positive integer value, passed to \code{\link{postopNCK}};
it is sometimes but not always beneficial to increase it versus the default 1}

\item{seed}{the seed for making \code{\link{postopNCK}} reproducible;\cr
if \code{NULL}, it will be randomly determined and reported with the result}

\item{...}{currently not used}

\item{nlevels}{a vector of numbers of levels, or a data.frame that is the table
of that vector, with levels in decreasing order and column names \code{level}
and \code{frequency}; function \code{MCA2} always sorts the numbers of levels
into decreeasing order}

\item{internet}{logical: is an internet connection available (for DWYER or NIST download)}
}
\value{
Functions \code{MCA2} and \code{CA_to_MCA} return a matrix of class \code{ca}
with attributes of the ingoing matrix (dimensions modified),
and attributes \code{Call} and \code{seed} modified,
and often with flexible values in most columns. For function \code{MCA},
the number of levels is in decreasing order
(regardless of the order specified in \code{nlevels}).\cr
Function \code{N_upper_MCA} returns an upper bound for the run size of an MCA
obtainable via the constructions (named integer, obtained by \code{\link{bestN}},
where the size can be obtained by using the CA of the construction indicated
by the name as the \code{D} in function \code{CA_to_MCA}).\cr
Function \code{projBoseMCA} returns a matrix of class \code{ca} with attributes;
for numeric \code{nlevels}, the columns are in the order of \code{nlevels}, otherwise
the columns with more levels come before the columns with fewer levels.
}
\description{
either from a given CA D, by makes unused levels of some columns flexible (
arbitrary strength), or for strength 2 only,
from required numbers of levels, by a construction generalized from Sherwood (2008).
In either case, the result is treated by function postopNCK for reducing its
run size.
}
\section{Details}{

Function \code{MCA2} implements Groemping's (2025) generalization of the first
construction of Sherwood (2008) for creating mixed covering arrays (MCAs).
The algorithm is described in Groemping (2025). Its key idea is to
start from a uniform CA, make superfluous levels flexible, and expand
columns with enough flexible entries into more columns of the same number of levels,
using a recursive substitution of flexible values with ordered designs.
The result is then post-processed by function \code{\link{postopNCK}},
unless this is suppressed by the argument \code{outerRetry=0}. Post-processing
can also be done separately by directly using function \code{\link{postopNCK}}
on the result of function \code{MCA2}, regardless whether it was created with
or without post-processing.

Function \code{CA_to_MCA} sets unused levels of the columns in \code{cs} to \code{NA}, i.e.,
makes them flexible, as, e.g., described in Moura et al. (2003). Subsequently, the function
\code{\link{postopNCK}} applies the method of Nayery et al. (2013) for
making entire rows flexible and removing them. Repeated runs can remove more rows.
The \code{outerRetry} argument gives the number of calls to \code{\link{postopNCK}}.
if the bottom rows of the outcome still look promising, the function can be called
again for removing even more rows.

Without specifying a seed, the results will differ from call to call.
The seed, even
if not explicitly specified, is stored with the output, so that the result will
always be reproducible, if desired.

The run size optimization can take a long time. It can be suppressed by setting
\code{outerRetry} to zero, and this should be done for large settings.
Per default, the optimization is switched on. Its progress is reported
by interim messages. The functions react beneficial to user interrupts: They
return the result from the previous successful \emph{outer} retry (make sure the outer
retry has finished before escaping calculations!).

Function \code{N_upper_MCA} reports an upper bound on the run number for an MCA
of the setting. That bound is obtained by using function \code{\link{bestN}} for
the maximum number of levels with the total number of columns. Depending on the situation,
the bound may be sharp (e.g., for eight five-level columns with two 3-level columns)
or dramatically too large (e.g., for one eight-level column with ten 2-level columns).

Function \code{projBoseMCA} implements Theorem 2.3 of Colbourn (2008) as well as
Corollary 2.2 of the same paper, which also references Stevens, Ling and Mendelsohn
(2002, their Theorem 2.6). It works for two different numbers of levels only.
It is most powerful for q+1 columns at q-1 levels with a single column at q+1 levels,
where q is a prime power (the Corollary 2.2 situation);
in these cases the run size is optimal ((q-1)*(q+1)=q^2-1).
}

\section{Warning}{

There is not much experience yet with the post-optimization performance.
The defaults for the related parameters may change in the future.
}

\examples{
##################################################
### MCA2
##################################################
## small example with fast optimization to global optimum
## which is 2*8
## 16 runs
D <- MCA2(c(rep(2,10), 8))
dim(D)
coverage(D, 2)
## N_upper_MCA is very pessimistic
N_upper_MCA(c(rep(2,10), 8))

## another case for which N_upper_MCA seems to be tight
N_upper_MCA(c(rep(5,8), 3,3))
D <- CA_to_MCA(CS_LCDST(10,5), 9:10, c(3,3), outerRetry=0)
dim(D)
head(D); tail(D)

\dontrun{
## optimize run size (using a good seed)
D <- MCA2(c(rep(2,30), rep(3,2)), seed=17369, outerRetry=3)
coverage(D, 2)
attributes(D)
## reasonably quickly reduces to 11 runs on my Windows machine
## lower bound is 9 runs (3*3)
## CAgen yields 14 runs with IPOG-F
}

## create a large design without trying a run size optimization
D <- MCA2(c(rep(2,70), rep(3,80), rep(4,8), rep(6,2)),
         outerRetry=0)
dim(D)
coverage(D, 2)
## alternative call for the same setting
D <- MCA2(data.frame(levels=c(6,4,3,2), frequency=c(2,16,80,70)),
         outerRetry=0)
\dontrun{
## this runs for a long while, and it is not known whether a reduction
## can be achieved; the code can be interrupted and returns the latest
## improved array (if any)
Doptimized <- postopNCK(D, 2)
}

## calls with more extreme numbers of levels
D <- MCA2(c(13,11,rep(4,8), rep(2,20)), outerRetry=0)
## 169 x 30
## minimum run size is known to be 13*11=143
## obtained relatively fast with postopNCK

D <- MCA2(c(13,rep(4,8), rep(3,12), rep(2,20)), outerRetry=0)
## 169 x 41
## lower bound for run size is 13 * 4 = 52
## postopNCK with seed 3318, innerRetry=3:
##    169 quickly shrunk to 64 runs (after 9 outer retries)
##    reasonably quickly to 59 runs (after 13 outer retries),
##    then slowly to 53 runs (after 19 outer retries)
##    stopping short of reaching the known lower bound 52
##    within the default settings for outer retries

## use the argument D
D <- MCA2(c(rep(5,1), rep(4,2), rep(3,7), rep(2,20)),
         outerRetry=0)

########################################################
### CA_to_MCA
########################################################
# a small example
## six 3-level columns in 33 runs
D <- bestCA(3,6,3)
## to three 3-level and three 2-level columns in 27 runs
Dmixed <- CA_to_MCA(D, cs=4:6, tolev=rep(2, 3), t=3, outerRetry=0)
dim(Dmixed)
## (optimal)
coverage(Dmixed, 3)
## works

## five 3-level columns in 33 runs
D <- bestCA(3,5,3)
## to four 3-level columns and one 2-level column in 33 runs,
## i.e., a lengthy search cannot reduce the number of runs;
## the 27 run OA(27,3,4,3) cannot easily be expanded by a 2-level column
## without increasing the number of levels
\dontrun{
Dmixed <- CA_to_MCA(D, cs=5, tolev=2, t=3) ## last three columns reduced to 2 levels,
}

## larger example
D <- bestCA(3, 12, 5)
dim(D)
## 225 runs for 555555555555 levels
## can be reduced to 177 runs for 555554433222 levels
## not run because of run time;
## more reduction might be possible, though the eighth interim run
## of the second round already failed
\dontrun{
Dmixed <- CA_to_MCA(D, cs=6:12, tolevs=c(4,4,3,3,2,2,2), seed=28661)
dim(Dmixed)  ## 184 x 12
head(Dmixed)
tail(Dmixed)
## still looks promising for further row reductions
## no problem to continue from the result array that already
##     has the correct number of levels
## could also use postopNCK directly, but no need
Dmixed2 <- CA_to_MCA(Dmixed, cs=6:12, tolevs=c(4,4,3,3,2,2,2), seed=7199)
dim(Dmixed2)
tail(Dmixed2)
## there may still be potential for more reduction,
## but not too bad
}

######################################################
####           projBoseMCA               #############
######################################################

## corollary 2.2 cases (a single number of levels is different,
## and two larger than the others)
D <- projBoseMCA(c(rep(4,6),6))
head(D)
dim(D) ## 24 runs like IPOG-F for CAgen

D <- projBoseMCA(c(rep(6,8),8))
head(D)
dim(D) ## 48 runs, better than the 60 for IPOG-F
       ## which is best for CAgen and the 58 of JMP Pro
       ## as of 11 August 2025

## the single different number can also be smaller
## then not guaranteed to be optimal
D <- projBoseMCA(c(rep(6,8),7))
head(D)
dim(D) ## 48 runs, better than the 60 for IPOG-F
       ##  42 would be a guaranteed optimal

D <- projBoseMCA(c(rep(6,8),4))
head(D)
dim(D) ## 48 runs, better than the 55 for IPOG-F
       ##  36 would be a guaranteed optimal

## cases with two groups of alphabet sizes
## the larger alphabet must be more frequent
D <- projBoseMCA(c(rep(4,5), rep(3,4)))
dim(D)  ## based on q=8 and c=4,
        ## there could be up to 9 4-level columns
D <- projBoseMCA(c(rep(4,9), rep(3,4)))
dim(D)  ## 60 runs, larger than 30 for IPOG-F2

## better use CA_to_MCA for this setting
D <- CA_to_MCA(bestCA(2,13,4), 10:13, rep(3,4), outerRetry=0)
dim(D)  ## better than CAgen, even without postoptimization

}
\references{
Colbourn (2008), Groemping (2025), Moura et al. (2003), Nayeri et al. (2013),
Sherwood (2008), Stevens, Ling and Mendelsohn (2002)
}
\author{
Ulrike Groemping
}
