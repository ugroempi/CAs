% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/productCA.R
\name{productCA_raw}
\alias{productCA_raw}
\alias{productCA}
\title{Direct product and generalized direct product for two CAs}
\usage{
productCA(D1, D2, check=TRUE, dupremove=TRUE, generalized=TRUE, ...)

productCA_raw(D1, D2)
}
\arguments{
\item{D1}{an N x k CA of strength 2 with v levels}

\item{D2}{an M x l CA of strength 2 with v levels}

\item{check}{logical; if TRUE, checks required strength of ingoing CAs (may substantially increase run time for large CAs)}

\item{dupremove}{logical; if TRUE, removes duplicated rows}

\item{generalized}{logical; if TRUE, exploits constant rows, which implies that function \code{\link{maxconstant}} is used to maximize constant rows,
which can reduce \code{N+M} by up to \code{v} (and at least by two); the price is run time.}

\item{...}{further arguments to function \code{\link{maxconstant}}, e.g., \code{one_is_enough}, which is per default FALSE}
}
\value{
Function \code{productCA} returns a CA(N + M -  min(v, s+r), 2, kl, v) (matrix of class \code{ca}).\cr
Function \code{productCA_raw} returns the simple (N + M) x (k*l) direct product of its two arguments.
}
\description{
Functions to construct a CA from a (generalized) direct product of two ingoing CAs
}
\section{Details}{

Function \code{productCA} yields a CA(N + M -  min(v, s+r), 2, kl, v) from a product
construction,\cr
for which \code{D1} can be rearranged to have s constant rows \cr
and \code{D2} can be rearranged to have r constant rows \cr
as proposed in Corollary 4.3 of Colbourn and Torres-Jim√®nez (2013)\cr
(removal of duplicates may reduce run size further, for very poor ingoing arrays).\cr
For large and efficient ingoing arrays, it may be wise to specify \code{one_is_enough=TRUE}
(as part of \code{...});
in that case, the search for the maximum number of constant rows is skipped,
and the resulting run size is N + M - 2.

Function \code{productCA} also serves as work horse function for combining two CAs in some instances of
the \code{\link{CAEX}} construction.

Function \code{productCA_raw} is mainly meant for calculation of interim results in other
functions, e.g., \code{\link{productPCA}}.
It works on any pair of numeric matrices that do not need to be integer-valued or CAs (see Examples Section).
}

\examples{
#########################################
## productCA
#########################################
###  (N+M-2 x k*l matrix)
A <- cyc(19,2)
B <- KSK(k=12)
dim(A); dim(B)
E <- productCA(A, B)
dim(E)
coverage(E, 2)
## 19 + 7 - 2 runs, twice as large as the optimal 12
eCAN(2,228,2)

A <- lhs::createBose(4, 5, bRandom=FALSE)
dim(A)
E <- productCA(A, A)
coverage(E, 2)
dim(E)  ## 30 runs with 25 columns, close to optimal
eCAN(2, 25, 4) ## 29 runs
eCAK(2, 30, 4) ## 30 columns

## from two CAs with many constant rows
## (not useful for this particular A, for demo purposes only)
A <- lhs::createBush(4, 5, bRandom=FALSE)
dim(productCA(A,A)) ## using default behavior
                     ## that exploits maximum constant rows
                     ## reduces N+M by up to v runs
dim(productCA(A,A, one_is_enough=TRUE))
                     ## preventing function maxconstant from conducting a
                     ## clique search, reduces N+M by 2 runs

## the function also works for designs with flexible values (which are denoted by NA)
## productCA
D <- productCA(CAEX(N=16), CAEX(N=16))
dim(D)
eCAN(2,441,3) ## slightly worse than the best CA, which is obtained as CAEX(N=28)
eCAK(2,30,3) ## a lot more columns are possible in 30 runs

### productCA_raw works on arbitrary numeric matrices
### and applies the simple direct product
A <- matrix(1:12, nrow=4)
B <- matrix(10*(1:6), nrow=3)
productCA_raw(A, B)

}
\references{
Colbourn and Torres-Jimenez (2013)
}
