% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/productCA.R
\name{dpCA}
\alias{dpCA}
\alias{productCA}
\alias{productCA_raw}
\title{Direct product and generalized direct product for two CAs}
\usage{
dpCA(k, v, ...)

productCA(D1, D2, c1=NA, c2=NA, check=FALSE, dupremove=TRUE, generalized=TRUE, ...)

productCA_raw(D1, D2)
}
\arguments{
\item{k}{number of columns}

\item{v}{number of levels}

\item{...}{further arguments to function \code{\link{maxconstant}},
e.g., \code{one_is_enough=TRUE} in case of large \code{D1} and \code{D2}.}

\item{D1}{an N x k CA of strength 2 with v levels}

\item{D2}{an M x l CA of strength 2 with v levels}

\item{c1}{for \code{generalized=TRUE}, number of constant rows at the top of \code{D1};
specifying this (correctly) substantially speeds up the function
for large \code{D1}}

\item{c2}{for \code{generalized=TRUE}, number of constant rows at the top of \code{D2};
specifying this substantially speeds up the function for large \code{D2},
if \code{D1} has fewer than \code{v} constant rows (ignored otherwise)}

\item{check}{logical; if TRUE, checks required strength of ingoing CAs
(may substantially increase run time for large CAs)}

\item{dupremove}{logical; if TRUE, removes duplicated rows of the result (if any)}

\item{generalized}{logical; if TRUE, exploits constant rows.\cr
\code{TRUE} is the recommended choice, as it reduces the number of runs
from \code{N+M} to a run size between \code{N+M-v} and \code{N+M-2}, depending
on the number of constant rows.}
}
\value{
Function \code{productCA} returns a CA(N + M -  min(v, s+r), 2, kl, v) (matrix of class \code{ca}).\cr
Function \code{productCA_raw} returns the simple (N + M) x (k*l) direct product of its two arguments.
}
\description{
Functions to construct a CA from a (generalized) direct product of two ingoing CAs
}
\section{Details}{

Function \code{dpCA} yields a uniform strength 2 CA with \code{k} columns in \code{v} levels,
based on the pre-inspected combination of ingredient CAs contained in the data frame
\code{\link{DPcat}}; the calculations invoked use the function \code{productCA} that implements
(a simple form of) the generalized direct product construction presented in Colbourn and
Torres-Jimenez (2013).

Function \code{productCA} yields a CA(N + M -  min(v, s+r), 2, kl, v) from a product
construction,\cr
for which \code{D1} can be rearranged to have s constant rows \cr
and \code{D2} can be rearranged to have r constant rows \cr
as proposed in Corollary 4.3 of Colbourn and Torres-Jim√®nez (2013)\cr
(removal of duplicates may reduce run size further, for very poor ingoing arrays).\cr
For large and efficient ingoing arrays, it may be wise to specify \code{one_is_enough=TRUE}
(as part of \code{...});
in that case, the search for the maximum number of constant rows is skipped,
and the resulting run size is N + M - 2.

Function \code{productCA} also serves as work horse function for combining two CAs in some instances of
the \code{\link{CAEX}} construction.

Function \code{productCA_raw} is mainly meant for calculation of interim results in other
functions, e.g., \code{\link{productPCA}}.
It works on any pair of numeric matrices that do not need to be integer-valued or CAs (see Examples Section).
}

\examples{
############################
#### dpCA ##################
############################
Ns(2, 25, 6)
D <- dpCA(25, 5)
coverage(D, 2)

#########################################
## productCA
#########################################
###  (N+M-2 x k*l matrix)
A <- cyc(19,2)
B <- KSK(k=12)
dim(A); dim(B)
E <- productCA(A, B)
dim(E)
coverage(E, 2)
## 19 + 7 - 2 runs, twice as large as the optimal 12
eCAN(2,228,2)

A <- lhs::createBose(4, 5, bRandom=FALSE)
dim(A)
E <- productCA(A, A)
coverage(E, 2)
dim(E)  ## 30 runs with 25 columns, close to optimal
eCAN(2, 25, 4) ## 29 runs
eCAK(2, 30, 4) ## 30 columns

## from two CAs with many constant rows
## (not useful for this particular A, for demo purposes only)
A <- lhs::createBush(4, 5, bRandom=FALSE)
dim(productCA(A,A)) ## using default behavior
                     ## that exploits maximum constant rows
                     ## reduces N+M by up to v runs
dim(productCA(A,A, one_is_enough=TRUE))
                     ## preventing function maxconstant from conducting a
                     ## clique search, reduces N+M by 2 runs

## the function also works for designs with flexible values (which are denoted by NA)
## productCA
D <- productCA(CAEX(N=16), CAEX(N=16))
dim(D)
eCAN(2,441,3) ## slightly worse than the best CA, which is obtained as CAEX(N=28)
eCAK(2,30,3) ## a lot more columns are possible in 30 runs

### productCA_raw works on arbitrary numeric matrices
### and applies the simple direct product
A <- matrix(1:12, nrow=4)
B <- matrix(10*(1:6), nrow=3)
productCA_raw(A, B)

}
\references{
Colbourn and Torres-Jimenez (2013)
}
