% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/greedySCA_Kuhn.R
\name{greedySCA_Kuhn}
\alias{greedySCA_Kuhn}
\alias{iter_greedySCA_Kuhn}
\title{Greedy random creation of an SCA}
\usage{
greedySCA_Kuhn(k, t, nsamp=10, postopt=TRUE, seed=NULL, ...)

iter_greedySCA_Kuhn(niter, k, t, nsamp=10, postopt=FALSE,
    seed_init=NULL, verbose=TRUE, ...)
}
\arguments{
\item{k}{positive integer (at least t); the number of columns}

\item{t}{the strength for which the coverage of all permutations of length t must be guaranteed for all \code{combn(k,t)} t-element subsets of 1,...,k}

\item{nsamp}{the number of runs sampled in each step of the algorithm (the N of the paper); the default 10 will likely be too small for realistic applications}

\item{postopt}{logical; default depends on function; if TRUE, the function \code{\link{reduce_rows_iterative_complete}} tries to make rows redundant and remove them. If this takes too long, \code{postopt} should be FALSE.}

\item{seed}{an optional positive integer seed for random sampling; specifying a seed makes the array generation reproducible}

\item{...}{currently not used}

\item{niter}{the number of independent attempts to make}

\item{seed_init}{an optional positive integer seed for the first iteration; specifying a seed makes the array generation reproducible}

\item{verbose}{logical (default TRUE), controlling how much printed output is created}
}
\value{
a strength t SCA with k columns; all rows contain the integers 1 to k.
}
\description{
for k columns and strength t according to an algorithm by Kuhn et al. (2012)
}
\section{Details}{

The function \code{greedySCA_Kuhn} implements the construction of Kuhn et al. (2012). It starts
from t! random permutations of the the integers 1,...,k and adds a further random permutation,
until all orders of all t-tuples are covered.\cr
For \code{postopt=TRUE}, it then \emph{identifies the redundant elements and removes all rows that
contain redundant elements only (would be easiest, but at present not done)} applies iterative run size reduction
using function \code{reduce_rows_iterative_complete}.

The function \code{iter_greedySCA_Kuhn} iteratively repeats the process and keeps the best
outcome.
}

\section{Use of AI}{

Claude 4 was involved in the development of these functions (mainly for debugging).
}

\examples{
## without post-optimization
nrow(greedySCA_Kuhn(5, 3, seed=2323, postopt=FALSE))
## relatively unlucky
nrow(greedySCA_Kuhn(5, 3, seed=2415, postopt=FALSE))
## relatively lucky
nrow(A <- greedySCA_Kuhn(5, 3, seed=16, postopt=FALSE))
coverageSCA(A, 3)
coverageSCA(A, 4)

## with post-optimization
## differences become smaller (still relevant esp. for larger cases)
nrow(greedySCA_Kuhn(5, 3, seed=2323))
## relatively unlucky
nrow(greedySCA_Kuhn(5, 3, seed=2415))
## relatively lucky
nrow(A <- greedySCA_Kuhn(5, 3, seed=16))
coverageSCA(A, 3)
coverageSCA(A, 4) ## worse coverage of 4-sequences than for larger SCA

## iteration
nrow(iter_greedySCA_Kuhn(10, 5, 3, seed_init=2415)) ## start unlucky
  ## larger niter brings the run size down to 8
}
\references{
Kuhn et al. (2012)
}
\seealso{
\code{\link[=greedySCA_naive]{greedySCA_naive()}} for a naive random assembly of an SCA and \code{\link[=greedySCA_TJ]{greedySCA_TJ()}} for the graph-based greedy stage method of Torres-Jimenez et al. (2022)
}
\author{
Ulrike Groemping
}
