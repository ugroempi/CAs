% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/coverage.R
\name{coverage}
\alias{coverage}
\alias{coverage_iter}
\alias{prepcoverplot}
\alias{coverplot}
\title{coverage and diagnostic plot functions}
\usage{
coverage(D, t, isInteger=TRUE, verbose=0, start0=TRUE, parallel=1)

coverage_iter(D, t, isInteger=TRUE, start0=TRUE,
       progress=FALSE, abortnot1=FALSE, start.proj=1)

coverplot(coverageD, D=NULL, t=NULL, isInteger=TRUE, start0=TRUE,
    type="projections",
    main=NULL, xlab=NULL, ylab=NULL,
    col=rgb(0,0,1,0.5), las=1, plot=TRUE, ...)
}
\arguments{
\item{D}{array}

\item{t}{small positive integer, interaction strength to be considered}

\item{isInteger}{logical (default \code{TRUE}): are the elements of D all
consecutive integers starting with 0 or 1?}

\item{verbose}{0 (default) returns only four percentages, 1 and 2 return more detail.
Anything apart from 1 and 2 behaves like 0.}

\item{start0}{logical (default \code{TRUE}): do the integers start with 0 ? (irrelevant for \code{!isInteger})}

\item{parallel}{number of threads to be used (default: 1); if increased, package parallel must be available}

\item{progress}{logical (default \code{FALSE}): should a progress bar be printed ?}

\item{abortnot1}{logical (default \code{FALSE}): should the function stop at the first projection for which
strength \code{t} coverage is not perfect ?}

\item{start.proj}{integer, the number of the projection to start with in lexicographical
order; ignored for \code{abortnot1=FALSE}; for \code{abortnot1=TRUE}, assumes that all
projections up to \code{start.proj - 1} were already successfully checked}

\item{coverageD}{a class \code{coverage} object created by function \code{coverage} with at least \code{verbose=1}.
for \code{verbose} less than 2, \code{t} must be specified. If \code{coverageD} is specified,
all arguments referring to the design \code{D}, except for \code{t} in case of verbosity 1 only, are ignored.}

\item{type}{\code{"projections"} (default) or \code{"tuples"}}

\item{main}{title of plot}

\item{xlab, ylab}{axis titles}

\item{las}{orientation of tickmark labels}

\item{col}{color}

\item{plot}{logical (default \code{TRUE}): generate the plot?}

\item{...}{further arguments to polygon}
}
\value{
Functions \code{coverage} and \code{coverage_iter} return an object of S3 class \code{coverage}, which is a
list with elements
\item{total}{total proportion of covered \code{t}-tuples}
\item{ave}{average of \code{t}-tuple proportions taken over projections}
\item{min}{the minimum proportion of \code{t}-tuples covered among the projections}
\item{simple}{proportion of projections which are fully covered}
\item{tots}{\code{coverage} with \code{verbose=1}: the number of \code{t}-tuples for the projections}
\item{ncovered}{\code{coverage} with \code{verbose=1}: the number of covered \code{t}-tuples for the projections}
\item{proportions}{\code{coverage} with \code{verbose=1}: \code{ncovered/tots}-tuples for the projection}
\item{projections}{\code{coverage} with \code{verbose=2}: the projections in a \code{t}-row matrix, a column for each projection}
\item{tabs}{\code{coverage} with \code{verbose=2}: a list of tables (for mixed levels CAs) or a matrix (for uniform CAs) that shows the number of coverages for each tuple in each projection; the row order of \code{tabs} is the same as is used for the numbering of tuples in \code{notcovered} (see next item) }
\item{notcovereds}{\code{coverage} with \code{verbose=2}: a list of vectors of position numbers of the not-covered tuples for the projection, where position numbers arise having the left-most factor changing fastest}
\item{message}{\code{coverage_iter} with \code{abortnot1=TRUE}: message which projection was the first uncovered one and thus stopped the calculations}

The \code{coverplot} functions return a list of coordinates \code{x} and \code{y}, strength \code{t}
and \code{proportions} (from call with \code{verbose=1}).
}
\description{
functions for calculating covering proportions for a given strength,
and for visualizing those
}
\section{Details}{

Function \code{coverage_iter} calculates the same quantities as function \code{coverage};
instead of creating all projections at once, it creates them iteratively, which is slower
but doable for large cases for which function \code{coverage} fails for memory reasons.
This iterative version is, at least at present, not parallelized. It allows a progress bar
(which slightly deteriorates run time, e.g., on my Windows 10 machine, about 7 milliseconds
per 1000 projections). It also allows to request abortion on encountering the first violation
of strength \code{t} coverage.\cr
In case of aborting, the function returns \code{NA} values for
all four metrics, and as a fifth list element, the message at which projection the violation
occurred; \code{coverage_iter} does not have a \code{verbose} argument, but using the
\code{verbose} argument on printing an object that resulted from an aborted run prints
that message.\cr
For \code{abortnot1=TRUE}, function runs that did not abort up to a particular
iteration can be restarted at the subsequent iteration. The actual restart point will be
the first projection starting with the same first element as the requested \code{start.proj}
e.g., for \code{t=3} and a matrix \code{D} with 6 columns, the first ten 3-factor projections
start with 1, followed by six projections that start with 2, three projections that start with 3
and a single projection that starts with 4 (10 + 6 + 3 + 1 = 20). \code{start.proj=12} will start
with the projection 2:3:4, i.e., the 11th projection,
which is the first that starts with 2. For projections that start with 1, the second factor is
also relevant for the start position: the first four projections have 2 in the second position,
then there are three with 3 in the second position, then two with 4, and finally one with 5.
Thus, for \code{start.proj=7}, \code{start.proj} will be reduced to 5, and the projection
is 1:3:4 (the first that starts with 1:3).

Per default, the print method for class \code{coverage} prints the first four
elements only.

Function \code{coverplot}, with \code{type=projections}, plots the
percentage of projections on the horizontal axis and
the coverage on the vertical axis (visualizing the average taken over projections);
with \code{type=tuples}, the percentage of tuples (i.e., projections as weighted by tuples)
is shown on the horizontal axis, visualizing the total percentage covered.
Sorting of the combinations on the horizontal axis is from best to worst coverage.
}

\section{Warning}{

For function \code{coverage_iter}, in case of starting at projection \code{start.now},
the user is responsible to ensure that all prior runs have also been checked; the calculated
values assume that the prior runs showed perfect coverage.
}

\examples{
## fixed levels
D <- KSK(k=10)
coverage(D, 2)
coverage(D, 3)
## mixed levels, total and ave are different
plan <- cbind(rep(0:2, each=3), c(rep(0:1, 4), 1), c(rep(0:1, each=4),0))
coverage(plan, 2)
## verbose content not printed per default
coverage(plan, 2, verbose=1)
print(coverage(plan, 2, verbose=1), digits=4, verbose=TRUE)
print(coverage(plan, 2, verbose=2), digits=4, verbose=TRUE)
## two of three projections fully covered,
## one covered 5/6 only

cD2 <- coverage(plan, 2, verbose=2)
coverplot(cD2, type="projections") ## 2/3 at 1, 1/3 at 5/6=0.833333
## the not fully covered projection involves the 3-level
## column and thus has 6/(6+6+4)=37.5 pct of the tuples instead of 1/3
coverplot(cD2, type="tuples")

## it is also possible to call coverplot on the design itself
##    however, repeated calls will then require recalculation
##    of coverage, which can be demanding.
##    Where storage space is problematic for verbose=2,
##    working directly with the design may be doable
##    (but time is likely also an issue).
##
coverplot(D=plan, t=2, type="projections")
coverplot(D=plan, t=2, type="tuples")

## the Hadamard based 16 run design for 14 columns
##    that is available from FrF2::pb;
##    the design has levels -1 and 1 and columns are factors
##    therefore, isInteger=FALSE has to be used
if (require(FrF2)){
   CA3.2tothe14 <- FrF2::pb(16, 14)
   print(coverage(CA3.2tothe14, 3, isInteger=FALSE))
   }

}
