% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CAN.R
\name{Ns}
\alias{Ns}
\alias{eCAN}
\alias{eCAK}
\alias{Ns_derive}
\alias{Ns_fuse}
\alias{N_fuseBoseCA}
\alias{N_SCA_Busht}
\alias{N_fuseBushtCA}
\alias{Ns_CK_doubling}
\alias{Ns_productCA}
\alias{N_NISTcat}
\alias{N_TJcat}
\alias{N_WKScat}
\alias{N_CKRScat}
\alias{N_miscCAcat}
\alias{N_DWYERcat}
\alias{N_PALEYcat}
\alias{N_CYCLOTOMYcat}
\alias{N_CAEX}
\alias{N_recBoseCA}
\alias{N_projBoseCA}
\alias{ks}
\alias{ks_productCA}
\alias{k_NISTcat}
\alias{k_TJcat}
\alias{k_WKScat}
\alias{k_CKRScat}
\alias{k_miscCAcat}
\alias{k_DWYERcat}
\alias{k_PALEYcat}
\alias{k_CYCLOTOMYcat}
\alias{k_CAEX}
\alias{k_fuseBoseCA}
\alias{k_SCA_Busht}
\alias{k_fuseBushtCA}
\alias{k_recBoseCA}
\title{Functions for N and k from Colbourn tables, other libraries, and implemented constructions}
\usage{
eCAN(t, k, v)

eCAK(t, N, v)

Ns(t, k, v, exclude=NULL)

Ns_derive(t, k, v, exclude=NULL)

Ns_fuse(t, k, v, maxfuse = 1)

N_fuseBoseCA(t,k,v)

N_fuseBushtCA(t,k,v)

Ns_CK_doubling(t=3, k, v)

Ns_productCA(t=2, k, v)

N_NISTcat(t, k, v)

N_TJcat(t, k, v)

N_WKScat(t=6, k, v=2)

N_CKRScat(t, k, v)

N_miscCAcat(t, k, v)

N_DWYERcat(t, k, v)

N_PALEYcat(t, k, v=2)

N_CYCLOTOMYcat(t, k, v)

N_CAEX(t=2, k, v=3)

N_recBoseCA(t=2, k, v, type="PCA")

N_projBoseCA(t=2, k, v, cmax=3)

ks(t, N, v)

ks_productCA(t=2, N, v)

k_NISTcat(t, N, v)

k_TJcat(t, N, v)

k_WKScat(t=6, N, v=2)

k_CKRScat(t, N, v)

k_miscCAcat(t, N, v)

k_DWYERcat(t, N, v)

k_PALEYcat(t, N, v=2)

k_CYCLOTOMYcat(t, N, v)

k_CAEX(t=2, N, v=3)

k_fuseBoseCA(t=2, N, v)

k_recBoseCA(t=2, N, v, type="PCA")
}
\arguments{
\item{t}{coverage strength}

\item{k}{number of columns}

\item{v}{number of levels for each column}

\item{exclude}{\code{NULL} or a character vector of method(s) to exclude,
in support of size calculations for recursive constructions
which need to calculate sizes of best ingredients}

\item{maxfuse}{integer number of levels to fuse (i.e., difference between number of levels before and after fusing)}

\item{N}{number of runs}

\item{type}{character string: \code{"PCA"} or \code{"CA"}}

\item{cmax}{integer number: maximum \code{c} to consider for projection (\code{N_projBoseCA} returns \code{NA},
if a design cannot be found within this limit; increase to \code{Inf}, if arbitrarily large N are of interest)}
}
\value{
\code{eCAN} returns a data frame with the smallest known run size
(empirical CAN, based on the Colbourn table)
and the corresponding source entry (Source),\cr
\code{eCAK} does the same with the largest possible number of columns \code{k},\cr
\code{N_NISTcat} returns the smallest run size for the requested \code{k} of a
catalogued array from the publicly available NIST covering array library,\cr
\code{k_NISTcat} returns the maximum column size for the requested \code{N} of a
catalogued array from the publicly available NIST covering array library,\cr
and \code{N_TJcat} returns the smallest run size for the requested \code{k} of a
catalogued array from the Jose Torres-Jimenez library (as of Feb 6 2025, small
selection, which is expected to grow; partly available in this package),\cr
and \code{k_TJcat} returns the largest number of columns \code{k} for the requested \code{N}
of a catalogued array from the Jose Torres-Jimenez library (as of Feb 6 2025, small
selection, which is expected to grow; partly available in this package)\cr
The analogous functionality holds for \code{N_} and \code{k_} functions for
\code{DWYERcat}, \code{CKRScat}, \code{miscCAcat}, \code{WKScat} and \code{CYCLOTOMYcat}, also for
\code{CS_MS}, \code{CS_LCDST}, \code{CS_CK} and various other constructions.
.
In cases for which there is no entry in the respective
table or library, the returned results are missing values.
}
\description{
The functions extract the number of runs needed for a specified setting
according to the Colbourn tables, according to the NIST library of CAs
and the Torres-Jimenez library of CAs, as well as according to implemented constructions
and available catalogues. Or they extract the number of columns
achievable for a specified number of runs.
}
\details{
Functions \code{eCAN} and \code{eCAK} provide the current best \code{N} for a given \code{k}
and vice versa, according to the Colbourn tables, including source information as stated in those tables.\cr
Functions \code{Ns} and \code{ks} provide the respective run sizes for
a requested number of columns \code{k} (\code{Ns}) or the affordable numbers
of columns from an affordable run size \code{N} (\code{ks}). They take into account all available
catalogues and constructions, for which sizes can be easily provided; their
scope will grow with time, and \code{Ns} is prioritized over \code{ks}, as it is considered
more important for applications.\cr
Functions \code{Ns_derive}, \code{Ns_fuse}, \code{Ns_CK_doubling},
\code{Ns_productCA}
provide run sizes from deriving, fusing, doubling or taking the product with
the smallest possible strength 2 CA for the requested \code{v}
in comparison to run sizes without applying such techniques. In case of doubling,
the function is restricted to strength $t=3$ (the only strength for which
Chateauneuf-Kreher doubling works) with $v=2,3$, for which a natural choice of a
the strength 2 design \code{D2} for \code{\link{CK_doubling}} is known (implemented
in functions \code{\link{KSK}} and \code{\link{CAEX}}, respectively).\cr
Functions \code{ks_derive} and \code{ks_fuse} provide affordable
numbers of columns from an affordable run size \code{N};
for doubling, this is more complicated and has not yet been implemented.

Specific functions for run sizes \code{N} and
numbers of columns \code{k} can also be inspected separately.\cr
The functions typically look for a value of \code{k} for \emph{at most}
\code{N} runs, and a value of \code{N} for at least \code{k} columns.\cr
The functions look for the exact strength \code{t}; this implies that a CA for a higher strength may exist,
where none is implemented for a lower strength.

At present, the individual functions,
except for \code{eCAN} and \code{eCAK}, return a number only.
This may change in the future.

For the \code{TJcat}-related functions, a message provides the command for
creating the CA, if a creation from within the package is possible (with one of
functions \code{CAEX} or \code{SCA_Bose}).
}
\examples{
eCAN(3, 199, 2)
N_NISTcat(3, 199, 2)
N_TJcat(3, 199, 2) ## equals the best-known array

eCAN(4, 199, 2)
N_TJcat(4, 199, 2) ## Colbourn table outdated

eCAK(2,11,3)  ## also obtained by CAEX
k_NISTcat(2,11,3)
k_TJcat(2,11,3) ## equals the best-known array

N_CYCLOTOMYcat(3, 45, 3) ## t=3 and v=3 not implemented
N_CYCLOTOMYcat(4, 45, 3) ## quite large!
k_CYCLOTOMYcat(4, 669, 3) ## can accommodate 224 columns
N_CYCLOTOMYcat(4, 5, 3) ## is the smallest *implemented*
                        ## cyclotomy strength 4 CA for 3 levels
N_CYCLOTOMYcat(4, 670, 3) ## the next smallest is for 1051 columns
eCAN(4, 670, 3)           ## which is a current optimum

# overview of available constructions
Ns(2, 45, 2)  ## function KSK is known to yield the overall optimum
              ## projBoseCA is very unsuitable, but Ns uses N_projBoseCA with cmax=Inf
N_projBoseCA(2, 45, 2, cmax=25)
N_projectionBose(45, 2)
Ns(2, 16, 11) ## CS_LCDST is the best,
              ## projBoseCA and CS_MS are competitive
Ns(3, 45, 2)  ## the best array is in the TJ or the DWYER-catalogue
   # D <- tjCA(3, 45, 2)
   # dim(D)
   # # Dwyer readable with internet connection or
   # pathGH <- "https://raw.githubusercontent.com/aadwyer/CA_Database/main/Repository/CA"
   # # the instruction line starts with a comment character and is ignored, therefore ninstruct=0
   # D <- readCA(paste0(pathGH, "/CA_26_3_46_2.txt"), ignore.chars=c("]", "["),
   #        ninstruct=0, sep=",")
   # # or
   # D <- dwyerCA(3, 45, 2)
Ns(3, 400, 2) ## powerCT construction is best
Ns(2, 800, 3) ## function CAEX produces the best available array
Ns(3, 200, 3) ## CK_doubling is the best implemented construction
Ns(4, 150, 3) ## cyclotomy is very competitive
Ns(4, 150, 2) ## TJ is best (function tjCA)
Ns(4, 50, 2) ## Paley and Cyclotomy are the same, and both optimal
Ns(4, 50, 3) ## the best easily available CA is
   # https://github.com/aadwyer/CA_Database/blob/main/Repository/CA/CA_507_4_53_3.txt
Ns(5, 50, 2) ## Paley is optimal
Ns(5, 500, 2) ## CS_CK is near-optimal
Ns(5, 50, 3) ## the best easily available CA is
   # https://github.com/aadwyer/CA_Database/blob/main/Repository/CA/CA_2067_5_50_3.txt
Ns(5, 500, 3) ## Cyclotomy is optimal
Ns(6, 50, 2) ## WKS is optimal
   # WKS_CAs['50']
Ns(6, 200, 2) ## CS_CK and Paley are optimal
Ns(6, 2000, 2) ## Cyclotomy is optimal
Ns(6, 200, 3) ## powerCT is best implemented,
              ## but far worse than optimum

Ns_CK_doubling(3, 22, 2)
## with doubling a Paley design for ceiling(22/2) columns,
## the optimum run size can be achieved

Ns_CK_doubling(3, 12, 3)
## the direct CKRS construction is best (ckrsCA)
}
