% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flexible.R
\name{markflex}
\alias{markflex}
\alias{flexpos}
\alias{uniquecount}
\alias{flexprofile}
\alias{postopNCK}
\title{Redundancy checks and profile}
\usage{
flexpos(D, t, ...)

uniquecount(D, t, ...)

markflex(D, t, fixrows=0, verbose=0, ...)

flexprofile(D, ...)

postopNCK(D, t, fixrows=0, verbose=0, outerRetry = 50, outerMaxnochange = 10,
       innerRetry=10, innerMaxnochange=25, seed=NULL, ...)
}
\arguments{
\item{D}{an N x k CA of strength t with v levels, coded from 0 to v-1 or from 1 to v; flexible values, if any, must be denoted as \code{NA}}

\item{t}{integer-valued (>=2), the strength of \code{D}}

\item{fixrows}{integer from 0 to \code{N} for preventing the top \code{fixrows} rows from being moved}

\item{verbose}{integer-valued degree of verbosity; 1 requests that the latest stages of unsuccessful attempts are added as an attribute to the returned unchanged matrix in case of a failure}

\item{...}{currently not used}

\item{outerRetry}{integer-valued number of retries for escaping local optimum, if \code{outerMaxnochange} iterations were not successful}

\item{outerMaxnochange}{integer-valued number of iterations to try and find optimum positions within a candidate row or its automatically-determined replacements}

\item{innerRetry}{integer-valued number of reshuffles for escaping local optimum, if \code{innerMaxnochange} iterations were not successful}

\item{innerMaxnochange}{integer-valued number of iterations to try and find optimum positions within a candidate row or its automatically-determined replacements}

\item{seed}{\code{NULL}, or an integer-valued seed for the random process;\cr
the seed becomes an attribute of the output object}
}
\value{
Function \code{flexpos} returns a logical matrix with \code{TRUE} values indicating
flexible positions of \code{D}. Any position that is already \code{NA} in \code{D} is set to \code{TRUE}.\cr
Function \code{markflex} returns the ingoing CA, with values denoted as before,
with rows potentially reordered (for facilitating all-flexible rows),
and with flexible positions changed to NA. \bold{this may change}\cr
Function \code{postopNCK} returns an object of class CA with prior attributes preserved
and attributes \code{Call} and \code{seed} augmented by the \code{postopNCK} call details.
}
\description{
Functions for manipulating flexible values: determination of flexible positions (flexpos),
determination of a flexible set (markflex), and calculation of the profile (flexprofile)
}
\section{Details}{

Function \code{flexpos} marks flexible \emph{positions}, i.e. positions all of whose \code{t}-way interactions are also covered
in at least one tuple without them. It will not work to treat all these positions as flexible \emph{at the same time},
because this would eliminate \emph{all} instances of the affected interactions.

Function \code{markflex} uses the greedy algorithm of @nayeriRandomizedPostoptimizationCovering2013 for marking elements
as flexible. It makes use of function \code{flexpos} for swapping rows so that it becomes more likely that entire rows
consist of wildcards (flexible set points).
It works reasonably fast for strength 2 or small \code{k}, but becomes slow for larger strength and/or many columns.
Nayeri et al. (2013) ascertain that the determination of the maximum set of flexible points is an NP-hard problem, and
this algorithm is not guaranteed to find the maximum flexible set.
The returned flexible positions tend to be at the bottom of the array.

Function \code{flexprofile} obtains the profile of column-wise flexible values for \code{D}.

Function \code{postopNCK} likely needs some tuning for speed and efficiency,
but is nevertheless often successful.\cr
It attempts to remove rows by trying to make entire rows
contain flexible values. It implements a variant of the proposed algorithm by Nayeri et al. (2013).
If successful, it returns \code{D} after removal of as many as possible flexible
rows, as created by \code{markflex}. If that immediate and cheap approach does not
work, the function tries to iteratively improve the number of flexible values in the
last row, until the row has flexible entries only. It that is not successful in a given
number of iterations (\code{innerMaxnochange}),
an inner retry step switches to a different last row to make flexible
(at most \code{innerRetry} attempts).\cr
An outer loop makes \code{outerRetry} such
attempts and keeps the user informed via messages about the current status.
If the user interrupts via the keyboard (\code{<Esc>} or \code{<Ctrl>-<c>}),
the result of the latest successful \emph{outer} retry is returned (make sure to
not abort iterations before the next outer retry was started).\cr
Without such an interrupt, if no attempt is successful,
the function returns the unchanged input matrix,
adding as an attribute a list with the last states of each retry,
if requested by the \code{verbose} argument.
}

\examples{
# identify flexible values
A <- cyc(19,2)
coverage(A, 3)
(AwithFlex <- markflex(A, 3))
coverage(AwithFlex, 3)

## also works for mixed levels
(L18withFlex <- markflex(DoE.base::L18, 2))
flexprofile(L18withFlex)
## last two rows removable
## row 16 only needed for pair 23 in first two columns
## change element [8,1] to 2 --> row 16 becomes removable
L18withFlex[8,1] <- 2
flexprofile(L18withFlex)  ## frequency reduced by 1 for column 1
(L18withFlexmod <- markflex(L18withFlex, 2))
## now, three rows can be removed
coverage(L18withFlexmod[1:15,], 2, start0=FALSE)

## do the replacement on the raw design
L18mod <- DoE.base::L18; L18mod[8,1] <- 2
(L18modwithFlex <- markflex(L18mod, 2, flexible="NA"))

## example of Colbourn and Torres-Jimenez (2013)
## Figure 2 of the paper
hilf <- strsplit(c("2222001", "0022222", "1121201", "0120110",
                        "2210202", "2102122", "1200020", "0211121",
                        "1012100", "2001210", "0000001", "1111012",
                        "2222222", "2222011"), "")
plan <- do.call(rbind, lapply(hilf, as.numeric))
dim(plan)

## flexpos marks all positions that are not involved in any unique pairs
flexpos(plan, 2)
## these cannot be simultaneously made flexible

## markflex creates actual flexible values (=don't care values)
## and moves flexible rows to the end
(planMod <- markflex(plan, 2))
## there are two rows with all values flexible (can be omitted)

coverage(planMod[1:12,], 2)     ## now optimal
eCAN(2,7,3)

## fixing the first two rows from being moved
## allows only one row to be removed
## fixing rows comes at a price
(planMod2 <- markflex(plan, 2, fixrows=2))

## if removal of rows is the goal,
## postopNCK does the entire job automatically
## and very fast for this trivial case
plan_postopNCK <- postopNCK(plan, 2, outerRetry=1)
dim(plan_postopNCK)
coverage(plan_postopNCK, 2)

plan_postopNCKfixtworows <- postopNCK(plan, 2, fixrows=2, innerRetry=2)
dim(plan_postopNCKfixtworows)
coverage(plan_postopNCKfixtworows, 2)

## postopNCK is fast on trivial problems like the above,
## but may take its time otherwise
}
\references{
Nayeri, Colbourn and Konjevod (2013)
}
