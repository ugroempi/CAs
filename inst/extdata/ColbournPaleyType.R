## paley type results of Colbourn 2015

paleytypes <- scan(what=list(q=0L, t3a=0L, t3b=0L, t3ha=0L, t3hb=0L,
                             t4a=0L, t4b=0L, t4ha=0L, t4hb=0L, t5a=0L, t5b=0L, t5ha=0L, t5hb=0L, t6a=0L, t6b=0L),
                   fill=TRUE)
7 2 1 1 0
229 56 55 24 24 24 23 6 6 6 5
11 3 2 1 0 1 0
233 57 56 25 24 24 23 6 6 6 5
13 2 1 1 0
239 60 59 26 26 26 25 8 8 8 7
17 3 2 1 1
241 59 58 26 26 26 25 8 8 8 7
19 5 4 2 1 1 0
251 63 62 28 27 28 27 8 8 8 7
23 6 5 2 1 2 1
257 63 62 28 28 28 27 8 8 8 7
29 6 5 2 2 2 1
263 66 65 29 28 29 28 9 8 9 8
31 8 7 3 2 3 2
269 66 65 29 28 28 27 9 9 8 7
37 8 7 3 2 2 1
271 68 67 30 29 30 29 9 9 9 8
41 9 8 3 2 2 1
277 68 67 30 30 30 29 9 9 9 8
43 11 10 4 3 4 3
281 69 68 31 30 30 29 9 9 9 8
47 12 11 4 4 4 3
283 71 70 31 31 31 30 9 8 9 8
53 12 11 4 4 4 3
293 72 71 32 32 32 31 10 10 10 9
59 15 14 6 5 6 5
307 77 76 34 34 34 33 11 11 11 10
61 14 13 5 4 4 3
311 78 77 35 34 35 34 11 10 11 10
67 17 16 6 6 6 5 1 1 1 0
313 77 76 34 34 34 33 10 10 10 9
71 18 17 7 6 7 6 1 1 1 0
317 78 77 35 34 34 33 10 10 10 9
73 17 16 7 6 6 5
331 83 82 37 36 37 36 11 11 11 10
79 20 19 8 7 8 7 1 1 1 0
337 83 82 37 36 36 35 11 11 11 10
83 21 20 8 8 8 7 1 1 1 0
347 87 86 39 38 39 38 13 13 13 12
89 21 20 8 8 8 7 2 2 2 1
349 86 85 39 38 38 37 12 12 12 11
97 23 22 9 8 8 7 2 2 2 1
353 87 86 39 38 38 37 12 12 12 11
101 24 23 10 10 10 9 2 2 2 1
359 90 89 40 40 40 39 14 13 14 13 1 1 1 0
103 26 25 10 10 10 9 1 0 1 0
367 92 91 41 41 41 40 14 14 14 13
107 27 26 11 10 11 10 2 2 2 1
373 92 91 41 40 40 39 14 14 14 13
109 26 25 11 10 10 9 2 2 2 1
379 95 94 43 42 43 42 14 14 14 13 1 0 1 0
113 27 26 11 10 10 9 2 2 2 1
383 96 95 43 43 43 42 15 15 15 14
127 32 31 13 13 13 12 3 3 3 2
389 96 95 43 43 42 41 14 14 14 13
131 33 32 14 13 14 13 3 2 3 2
397 98 97 44 44 44 43 15 15 15 14
137 33 32 14 14 14 13 3 3 3 2
401 99 98 45 44 44 43 14 13 13 12
139 35 34 15 14 15 14 3 3 3 2
409 101 100 46 46 46 45 16 16 16 15
149 36 35 15 14 14 13 4 4 4 3
419 105 104 47 47 47 46 16 16 16 15
151 38 37 16 15 16 15 4 4 4 3
421 104 103 47 46 46 45 16 16 16 15
157 37 37 16 16 16 15 4 4 4 3
431 108 107 49 48 49 48 16 15 16 15 2 2 2 1
163 41 40 17 17 17 16 4 4 4 3
433 107 106 49 48 48 47 16 16 16 15 1 0
167 42 41 18 17 18 17 4 4 4 3
439 110 109 50 49 50 49 16 16 16 15
173 42 41 18 18 18 17 4 4 4 3
443 111 110 50 50 50 49 17 17 17 16
179 45 44 19 19 19 18 5 5 5 4
449 111 110 50 50 50 49 17 17 17 16
181 44 43 19 18 18 17 3 2 2 1
457 113 112 51 50 50 49 18 18 18 17
191 48 47 21 20 21 20 6 6 6 5
461 114 113 52 52 52 51 18 18 18 17
193 47 46 20 20 20 19 6 6 6 5
463 116 115 53 52 53 52 18 18 18 17 2 2 2 1
197 48 47 21 20 20 19 5 5 5 4
467 117 116 53 53 53 52 19 18 19 18 2 2 2 1
199 50 49 21 21 21 20 6 5 6 5
479 120 119 55 54 55 54 19 19 19 18
211 53 52 23 22 23 22 6 6 6 5
487 122 121 55 55 55 54 20 19 20 19 2 2 2 1
223 56 55 24 24 24 23 7 7 7 6
491 123 122 56 55 56 55 20 20 20 19 2 2 2 1
227 57 56 25 24 25 24 7 7 7 6
499 125 124 57 56 57 56 20 20 20 19 2 2 2 1


paleytypes <- as.data.frame(paleytypes)
paleytypes <- paleytypes[DoE.base::ord(paleytypes),]
head(paleytypes)

## entries for (q %% 4) == 1: paley_mat(q) or rbind(0,paley_mat(q)) for halftype,
##                            Double(paley_mat(q)) or Double(rbind(0,paley_mat(q))) for full type,
## thus, constr II was initially handled wrongly
##     k is much smaller than in initial handling of constr

## correct the entry for q=7 in column t3ha to 0
paleytypes$t3ha[paleytypes$q==7] <- 0
## correct the entries for q=13 and q=17 for strength 3
paleytypes$t3ha[paleytypes$q == 13] <- 0  ## does not have strength 3
paleytypes$t3hb[paleytypes$q == 17] <- 0  ## does have strength 3 with added 1 row

## explore small prime powers
#coverage(Double(rbind(1,paley_mat(9))),3)  ## rbind(1,...) covers
paleytypes$t3a[paleytypes$q==9] <- 1
paleytypes$t3b[paleytypes$q==9] <- 0
## coverage(rbind(1,paley_mat(9)),3)  ## no 3-coverage

#coverage(Double(rbind(paley_mat(25)))[-c(1:9,26:34),],3)  ## rbind(1,...) covers
paleytypes$t3a[paleytypes$q==25] <- 9
paleytypes$t3b[paleytypes$q==25] <- 8
#coverage(rbind(1,paley_mat(25)),3)  ## nothing can be omitted
paleytypes$t3ha[paleytypes$q==25] <- 1
paleytypes$t3hb[paleytypes$q==25] <- 0
## is not a Hadamard matrix, result for all strong does not apply
#coverage(Double(rbind(1,paley_mat(25))),4)
# coverage(Double(paleyHad(25)),4)  ## nothing can be removed
paleytypes$t4a[paleytypes$q==25] <- NA
paleytypes$t4b[paleytypes$q==25] <- NA

#coverage(Double(paleyHad(27))[-c(1:8,29:36),],3)
paleytypes$t3a[paleytypes$q==27] <- 9
paleytypes$t3b[paleytypes$q==27] <- 8
#coverage(paleyHad(27)[-c(1:2),],3)
paleytypes$t3ha[paleytypes$q==27] <- 3
paleytypes$t3hb[paleytypes$q==27] <- 2
#coverage(Double(paleyHad(27))[-c(1,29),],4)
paleytypes$t4a[paleytypes$q==27] <- 2
paleytypes$t4b[paleytypes$q==27] <- 1

#coverage(Double(paley_mat(49)[-(1:17),]),3)  ## 17 rows can be omitted from paley_mat
paleytypes$t3a[paleytypes$q==49] <- 18
paleytypes$t3b[paleytypes$q==49] <- 17
#coverage(paley_mat(49)[-(1:8),],3)  ## 7 rows can be omitted from paley_mat
paleytypes$t3ha[paleytypes$q==49] <- 9
paleytypes$t3hb[paleytypes$q==49] <- 8
#coverage(Double(paley_mat(49)),4)  ## two rows can be omitted from paley_mat
paleytypes$t4a[paleytypes$q==49] <- 4
paleytypes$t4b[paleytypes$q==49] <- 3

## utility functions
Double <- function(M) rbind(cbind(0,M), 1-(cbind(0,M)))
eCANvec <- Vectorize(eCAN, c("k"))

# t-types and t-halftypes for the Paley matrices when q is a prime and q < 500.
# These are shown in Table 1; some interpretation is in order.
# t-type (3t; 4t; 5t; 6t)
# t-halftype (3ht; 4ht; 5ht; 6ht)
# types:
#   left: for entire Hadamard matrix,
#   right: for Hadamard matrix without first row
#         (i.e., Paley matrix with added constant column)
# half types:
#   left: Paley matrix with added constant row of 0 values (OA of strength 2)
#   right: Paley matrix
# the left-hand side halftype entry for strength 3 with q=7 must be wrong,
# as the coverage of that matrix is not 3 but 2 only, as five triples are not covered!

## bring together construction information and
## numerical results of Colbourn (2015)
qs_paleyI <- setdiff(primedat$q[primedat$q %% 4 == 3],c(3,7))
qs_paleyII <- primedat$q[primedat$q %% 4 == 1]
N_paleyI <- qs_paleyI+1
N_paleyII <- qs_paleyII+1  ## not the hadamard matrix but only part of it
N <- c(N_paleyI, N_paleyII)
both <- data.frame(N=N,
                   k=N-1,
                   q=c(qs_paleyI, qs_paleyII),
                   constr=rep(c("I","II"),
                              times=c(length(qs_paleyI), length(qs_paleyII))))
both <- both[ord(both),]
paleytypes <- merge(both, paleytypes, by="q", all.x=TRUE)
nrow(paleytypes)
paleytypes <- paleytypes[paleytypes$q<=500,] ## contains prime powers
paleytypes <- paleytypes[ord(paleytypes[,-1]),]

## create PALEYcat from the information in paleytypes
## matrices themselves all have strength 3
## remove as many rows as is possible for those that do not have strength 4
cat3 <- paleytypes[!is.na(paleytypes$t3ha) & paleytypes$t3ha>0 & (is.na(paleytypes$t4ha) | paleytypes$t4ha==0),]

## reduce N as much as possible
cat3$N <- cat3$N - cat3$t3hb ## better for those that have the same size
hilf <- cat3[is.na(cat3$N),]
cat3$N[is.na(cat3$N)] <- ifelse(hilf$constr=="I", hilf$q+1, 2*(hilf$q+1))
cat3$code <- ifelse(cat3$t3hb==0 | is.na(cat3$t3hb),
                    paste0("rbind(1,paley_mat(",cat3$q,"))"),
                    ifelse(cat3$t3hb==1,
                           paste0("paley_mat(",cat3$q,")"),
                    paste0("paley_mat(",cat3$q,")[-(1:",cat3$t3hb-1,"),]")
                    ))
# for (i in 1:nrow(cat3)){
#   print(i)
#   hilf <- eval(parse(text=cat3$code[i]))
#   if (!cat3$N[i]==nrow(hilf)) print("row size wrong")
#   if (!cat3$k[i]==ncol(hilf)) print("column size wrong")
#   if (cat3$k[i] < 100)
#   if (!min(unlist(coverage(hilf, 3)))==1) print("coverage 3 violated")
# }

cbind(cat3$N, t(eCANvec(3, cat3$k, 2)))
## strength 3 designs from doubling are not interesting and have thus been omitted

################# strength 4 ####################################
cat4 <- paleytypes[(!is.na(paleytypes$t4a) | !is.na(paleytypes$t4ha)) & is.na(paleytypes$t5ha),]
## reduce N as much as possible
cat4$N[cat4$t4ha==0 | is.na(cat4$t4ha)] <- 2*cat4$N[cat4$t4ha==0 | is.na(cat4$t4ha)]-2*cat4$t4b[cat4$t4ha==0 | is.na(cat4$t4ha)]
cat4$k[cat4$t4ha==0 | is.na(cat4$t4ha)] <- cat4$k[cat4$t4ha==0 | is.na(cat4$t4ha)] + 1
cat4$N[!(cat4$t4ha==0 | is.na(cat4$t4ha))] <- cat4$N[!(cat4$t4ha==0 | is.na(cat4$t4ha))] - cat4$t4hb[!(cat4$t4ha==0 | is.na(cat4$t4ha))]

## Double if t4ha is 0 or NA,
## remove t4b-1 rows from paley matrix, or add row of ones if t4b==0
cat4$code <- ifelse(cat4$t4ha==0 | is.na(cat4$t4ha),
              ## doubling is needed
                    ## is rbind with 1 needed, can it be left out, or does one even have
                    ##     to remove rows?
                    ifelse(cat4$t4b==0, paste0("Double(rbind(1,paley_mat(",cat4$q,")))"),
                           ## distinguish whether row omission from paley mat possible or not
                    ifelse(cat4$t4b==1,
                        ## rbind with 1 not needed, but no other rows omittable
                        paste0("Double(paley_mat(",cat4$q,"))"),
                        ## cat4$t4b - 1 rows omittable
                        paste0("Double(paley_mat(",cat4$q,")[-(1:",cat4$t4b-1,"),])"))),
              ## doubling is not needed
                    ifelse(cat4$t4hb==0 | is.na(cat4$t4hb),
                           paste0("rbind(1, paley_mat(",cat4$q,"))"),
                           ## distinguish whether row omission from paley mat possible or not
                           ifelse(cat4$t4hb==1,
                                  ## nothing to remove
                                  paste0("paley_mat(",cat4$q,")"),
                                  ## cat4$t4hb - 1 rows omittable
                                  paste0("paley_mat(",cat4$q,")[-(1:",cat4$t4hb-1,"),]"))))
# for (i in 1:nrow(cat4)){
#   print(i)
#   hilf <- eval(parse(text=cat4$code[i]))
#   if (!cat4$N[i]==nrow(hilf)) print("row size wrong")
#   if (!cat4$k[i]==ncol(hilf)) print("column size wrong")
#   if (cat4$k[i] < 100)
#     if (!min(unlist(coverage(hilf, 4)))==1) print("coverage 4 violated")
# }

cbind(cat4$N, t(eCANvec(4, cat4$k, 2)))

################### strength 5
cat5 <- paleytypes[!is.na(paleytypes$t5a) | !is.na(paleytypes$t5ha),]

## reduce N as much as possible
cat5$N[cat5$t5ha==0 | is.na(cat5$t5ha)] <- 2*cat5$N[cat5$t5ha==0 | is.na(cat5$t5ha)]-2*cat5$t5b[cat5$t5ha==0 | is.na(cat5$t5ha)]
cat5$k[cat5$t5ha==0 | is.na(cat5$t5ha)] <- cat5$k[cat5$t5ha==0 | is.na(cat5$t5ha)] + 1
cat5$N[!(cat5$t5ha==0 | is.na(cat5$t5ha))] <- cat5$N[!(cat5$t5ha==0 | is.na(cat5$t5ha))] - cat5$t5hb[!(cat5$t5ha==0 | is.na(cat5$t5ha))]


cat5[which(cat5$N-unlist(t(eCANvec(5, cat5$k,2))[,"CAN"])<=150),]

## Double if t5ha is 0 or NA, subtract t5b twice in matching rows
##   from the two parts

cat5$code <- ifelse(cat5$t5ha==0 | is.na(cat5$t5ha),
                    ## doubling is needed
                    ## is rbind with 1 needed, can it be left out, or does one even have
                    ##     to remove rows?
                    ifelse(cat5$t5b==0, paste0("Double(rbind(1,paley_mat(",cat5$q,")))"),
                           ## distinguish whether row omission from paley mat possible or not
                           ifelse(cat5$t5b==1,
                                  ## rbind with 1 not needed, but no other rows omittable
                                  paste0("Double(paley_mat(",cat5$q,"))"),
                                  ## cat5$t5b - 1 rows omittable
                                  paste0("Double(paley_mat(",cat5$q,")[-(1:",cat5$t5b-1,"),])"))),
                    ## doubling is not needed
                    ifelse(cat5$t5hb==0 | is.na(cat5$t5hb),
                           paste0("rbind(1, paley_mat(",cat5$q,"))"),
                           ## distinguish whether row omission from paley mat possible or not
                           ifelse(cat5$t5hb==1,
                                  ## nothing to remove
                                  paste0("paley_mat(",cat5$q,")"),
                                  ## cat5$t5hb - 1 rows omittable
                                  paste0("paley_mat(",cat5$q,")[-(1:",cat5$t5hb-1,"),]"))))

# for (i in 1:nrow(cat5)){
#   print(i)
#   hilf <- eval(parse(text=cat5$code[i]))
#   if (!cat5$N[i]==nrow(hilf)) print("row size wrong")
#   if (!cat5$k[i]==ncol(hilf)) print("column size wrong")
#   if (cat5$k[i] < 100)
#     if (!min(unlist(coverage(hilf, 5)))==1) print("coverage 5 violated")
# }

################ strength 6

cat6 <- paleytypes[!is.na(paleytypes$t6a),]

## reduce N as much as possible
cat6$N <- 2*cat6$N - 2*cat6$t6b
cat6$k <- cat6$k + 1

cat6[which(cat6$N-unlist(t(eCANvec(6, cat6$k,2))[,"CAN"])<=150),]

## Double if t5ha is 0 or NA, subtract t5b twice in matching rows
##   from the two parts

## doubling is needed for all cases
## rbind is needed for some cases,
## rows cannot be removed from the paley matrix in any case
cat6$code <- ifelse(cat6$t6b==0, paste0("Double(rbind(1,paley_mat(",cat6$q,")))"),
                        paste0("Double(paley_mat(",cat6$q,"))"))
# for (i in 1:nrow(cat6)){
#   print(i)
#   hilf <- eval(parse(text=cat6$code[i]))
#   if (!cat6$N[i]==nrow(hilf)) print("row size wrong")
#   if (!cat6$k[i]==ncol(hilf)) print("column size wrong")
# }

PALEYcat <- rbind(cbind(t=3, v=2, cat3[,c("k", "N", "code", "q")]),
                  cbind(t=4, v=2, cat4[,c("k", "N", "code", "q")]),
                  cbind(t=5, v=2, cat5[,c("k", "N", "code", "q")]),
                  cbind(t=6, v=2, cat6[,c("k", "N", "code", "q")]))

nconst_paley <- sapply(1:178, function(obj) {print(obj); hilf <- maxconstant(paleyCA(PALEYcat$t[obj], PALEYcat$k[obj]), verbose=2); length(attr(hilf, "constant_rows")$row_set_list)})
PALEYcat$nconst <- nconst_paley

save(PALEYcat, file="D:/rtests/CAs/data/PALEYcat.rda", compress="xz")
